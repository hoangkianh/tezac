{
  "transpiled": true,
  "noir_version": "1.0.0-beta.2+3278f71a05090dbd",
  "name": "NFT",
  "functions": [
    {
      "name": "transfer_in_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10846690067871036662": {
            "error_kind": "string",
            "string": "invalid owner"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "transfer_in_public"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "364657447181031001": {
            "error_kind": "string",
            "string": "invalid admin"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "finalize_transfer_to_private",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "10536464181608181124": {
            "error_kind": "string",
            "string": "transfer not prepared"
          },
          "11859452850824495745": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 60
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          }
        },
        "parameters": [
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hiding_point_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "finalize_transfer_to_private"
      ]
    },
    {
      "name": "public_get_name",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18105278452957613314": {
            "error_kind": "string",
            "string": "Function public_get_name can only be called statically"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBFJgAABAMmAgEEACYCAgQAHxgAAgABgEQkAAAARSQAAABGLQQAAYBEJwIAAgSARCYCAwQBOg0AAgADJSQAAACbHgIAAQAeAgACADI4AAEAAgADJgIBAQEjAgADAAAAbyQAAADEHgIAAQkmAgIAAQo4AQIDIwIAAwAAAIskAAAA1iYCAQADLgwAAQACLAwCASUnAIAEBHgADQAAAIAEgAMjAIADAAAAwykBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEF+0Le07wSjQI7AQECJS0AGMoYyg==",
      "debug_symbols": "7VXbbsIwDP2XPPfBjp0bvzJNqEBBlaoWlTJpQvz7EtSG0kWgsbKnvVRxdexzepzaJ7EpVsfdsqy3zUEs3k6iatZ5Vza1j07nTKzasqrK3XL8WkB4GHXBH/Z5HcJDl7edWKDWMhNFvQlHI32FbVkVYqH98TsYQA1gkCqCUabQzGx6NLPSEe0wAbYUS1uSOAa/Z8LCDNptBHvxf6h9Dt8Zo+/6ke+odERrNPe1O3ID2DHxRLujWbUj3GoPDPbVDN6xl1Mg/ppCOxhunHaSHnQNYmUHVk26hvjTLw5JEp9JeoaJ+Jkkl0qSykGfJDWY+xaT4oGB9LiLJuUxShuHHY3QElK1DVnq0YaB77fPYJxFRt4OjIQOBKLr5dN62m3mf2cSzpx99JG3Zb6qin45bo/1erQru899MVmb+7ZZF5tjW4QFet2dGPaPdBnx5ffyAamMjOfwPF8=",
      "brillig_names": [
        "public_get_name"
      ]
    },
    {
      "name": "_finalize_transfer_to_private_unsafe",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "10536464181608181124": {
            "error_kind": "string",
            "string": "transfer not prepared"
          },
          "11859452850824495745": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 60
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17028138060491915576": {
            "error_kind": "string",
            "string": "Function _finalize_transfer_to_private_unsafe can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          }
        },
        "parameters": [
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hiding_point_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_finalize_transfer_to_private_unsafe"
      ]
    },
    {
      "name": "transfer_to_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "4718290446670665014": {
            "error_kind": "string",
            "string": "NFT not found when transferring to public"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "private_get_symbol",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18192277837884173995": {
            "error_kind": "string",
            "string": "Function private_get_symbol can only be called statically"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAvJTQ6/yQ2u\nGRy1WrQApcd4h3c5JhbhGpayMs7r/91cEcC/8wnh4IOJMEAtgduNNJ1WTF9dNFSq3IAD+IjGhLkq\npMSp4qwuuCjx0Htwxn/mCh7hQNegO/Jgy2853CxpfAVH1mHImHbzIZQaOCwN5G5tHL8Bxxqz6rAT\nRc/1GQUqFmoIl5IvkrPS1FH0XuFybYrHT6RB8pYJhNhrjuxK0UASfB6RPKO0p8Bp+HSuM0dS8fsP\n4iovOVeKTsl3OPdA/CR2Uh8tPc1u/wkWw47YNsIfo/dFXF+bYqwNiZzgditIC5PEfq3G8XwUHCrk\n05UEXrDwPLvYnlGztnuLRFs7YF8HsBN3bTHZ+BxY1m5P0WVAjCBZGX2ZOw60qAQQxGztyQo/IdQq\nNyvNNSZUNNnLa0b0pLCAvrD6CVcVa/Px/wOMDIEHCGf27V9JMz7/ekq+Q0r1ENEHqGfXqg6xmkCK\nM+8WOuKVK6yhVI1ynsIH7tAOi7QEmKmot6ItdGNLJ230QQRWu3AbWwtGO7zwxP5xkFUjk9CVM+Gy\nAEvYTp+KU6iPA4D05rswR3a/1Psi4gmHdBVkgemj+PCR0w2xADptqrQpjDMR/JFw+S3pQLBCqrmQ\n1TxqOyYznNprc9+SCDFBWQewX0CKYShHJZAWuSBK5L83U36xlrBcHZj6UQFqm6y7LILfCnzPyu0k\nviK2aeWmmmyZu1xzSJITTd+3UOz1U08YJlfFiQTeCwGgWOVkt+LKhl6SpdK8LqJI/XMIJwMstRjP\nfnaQwQdAxjV5eHXC13qTQEQj5o5Xz+NuT0J37qKlABEpAacPI3jiNHGgt8EsOMMMz0XfEODo1VRR\neTFMc30Aph3qx2s3DKT0L3OmZct1qevcWM1L34r35/z/o21bcS5ZeJ8Nnbs/Fa3lOEt4SQ2x2DN5\nxzvkESPev8iMn8jWK3KtwTdDjKDTNxRFpXqWkOZE9YS6+kVBJM8BrVvgsTkBGeJB7rvr/1x9fyDc\nbFrRtq943CBtf3eFPwX95+vTcgB15RBVZZ0mI7he2DA0uYayiM+kJF+rYvQyt8oZJHBkKRjv0fxs\nfPCfSlYd8TNWktrC0SpTZ7wep9lFdxmgH50VuWtYVFSBZefyZKkkcz5/mCYEJ+3NfxzTkNDNJplm\n1Q8roTNLu1meTjvuYETTWAxzaE18iUsHRKKXZRK6E4qND7JQvEI6Q5JOb/TD31zKEryHF1i8y/Ce\n0wpFeSm3Azoi5sFbokCz5aSVggzXnT8SKT0uZz7YQ77QsJqb0N1nPwVCqeHtXPy9QrwBXtFJaiK5\nbnTpqDyTQYinpIvekD/HLzN8Vwx8Hhr4+yo6XBnDplvMGk0sBNI7kgYRcL17KVMtvxHWvxf2ItSz\nMhvHiaOGFqXnZYmdAZuYhpFrEZ3LQh5lvmKX1k3IFuHX15VrYTDHiOlpFdZKAlNerqo+qIsaLJa4\nb2B0iPFkO8EkLXm1MiVXBnROOyoGEzPkyxzJC8QWFrWqWP756aiaWSQihOMuLlyEIO3Oq8QSO0PS\nYCSDlS5IcRJh2xWtGPn3NKy9nFZzqOe7kSygQbIKAbn9BgduL06cLsCwfj+O8UKuHemlmuoDDRib\njPMuHyRAY43P8gsCMdNmhrGP9iYirbDNynHhNpaBWBEapxfoD8QO+XW80SmuWa/3HqC4pA9W9xlX\nTkz6yWHJ0rglS4BakL+h1QznINHECVGDXCbSXkSRdBGBoRIYxq6hymQNtY2Q4RyJ3ekWik/vQ8IS\noWZjQubFgFb1Gxajj+BvpI0pqzhnGXqhEyfXE3AfVh2zMcy+EzQDCbHPu5td8V+PiEhqSKuSb+Zz\nDVga7/RqFLyWBzyoVopEePoE7joSqJdTeWfLrWBE8nUK3InEjXW1cWNvW760qAb29FliAjAbauTr\nDrvq3SAzQAZvKBNXSPEZYxw/4H+p1wADTj4nRU75krS/hLl7qnRxLiV4NVHfUMAE7HzR9N2LO2Sm\nbyrEl5tl5WVoxaMbFO0Y92zwzuzLR5jedBrom2ToJY+ER3wbYlZaVZunuziDLi0pn7aGeNAVC8xb\nFtyCUjU9Q/pw6ZI5wcHGficaDurFFdOsWhmau3STOk78mMWbKBTt580n2u0AwzwShgvEsEYtONbU\nuh5HY6dOzbEcofNGloDCcOVRUVNEWS9ZGI+nZRLbOeiSgmsyYQ7gglHgBfzpF8DV3KAZR3xS9gdT\nMrYSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAg6bs2/ENrwMyOFjB0S0PSNrZJUNEvVIfL+YAuqhvHZoEG91H7rb3ycGG+JY/dwl\nUxLzgkuX4ChKVpnqQarPutwPy7+dPPQCuqPu2l8Knkm1werJWyZMMC3IVObyLXMw3yg+39qJyUgF\nl/CzRC6XUt751Y/Ckgg2GUJh97Fj/vuvHViqYcZK1SIEPXnEgCIZ5Vuhl1Gt/mw2Mk0/tsLaCYkt\nfBipPD2uWICfqu7GqGp49LO8YfGdbnBpNZu/R+f5Bw=="
    },
    {
      "name": "cancel_authwit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "inner_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7ZfBbtswDIbfReccSIqixLzKMBRO4hYGDCdwkgFD0HefnEWygyr1IVuxAb6J9g/y1ydRti5mV2/Oby9N97o/mvW3i2n32+rU7LsYXQza67PjoeqG8Hiq+pNZowitTN3thqGn95V5bdrarCUOP4iJxN/EREGzGMGV1MrhprZAOKNGYeuyE+YxO3ktZUeS5AXZjWqVUnYrNiVnhDv195VBXtg8ZOMWNg/ZyMLmIRv/NBsGTWJGClmscC0Q/nYBfboAWuAktnayulRUA/q0AHGsdmqotHWCat47+sE/wX/uH4v+wWred8DMM/0FCGm+BLFMlnsuyINomkHw1s40TODcMIE9z6itS2KmSbuUeos8ZjJ3NoqN6EfqXt2MGHJmBAlT8YCcFuRfjdwuyL8aOZeRs+MRuZfPkQs6uKkFg/v8qMMw+onwx3NUfp907k8YopC2gJDqk2ev/FuOYrDpm7Zt3l7ubjVwvdoU15MU0r8SqYN75u8x/FH1TbVp6yHR8PbcbVPeGJ5+HtKbVPnQ77f17tzXg4dJ+eE7i7IijGlj6l8=",
      "brillig_names": [
        "notify_created_nullifier_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "owner_of",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9443383425599897888": {
            "error_kind": "string",
            "string": "Function owner_of can only be called statically"
          },
          "9605075991997100073": {
            "error_kind": "string",
            "string": "token does not exist"
          }
        },
        "parameters": [
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "owner_of"
      ]
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5972837590977953198": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 36
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "packed_note_content",
            "type": {
              "kind": "array",
              "length": 3,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3djty2soXfxde+EMni336VjYMgfzswYNiBkxzgINjvfnraI3XPiNMMqyQOVVq5COJYpS5+q7pZq9Qt/f3hl19/+uu3Hz59+c/XPz78699/f/j89ecf//z09cvlT3//9+OHn759+vz5028/3P/vD9PTvzxdj//j9x+/PP3xjz9//Pbnh395+vjh1y+/fPhXsJfo/3z6/Ov1P//n4wef244PU+PxpvF423i8azy+kU/wjceHxuNj4/Gp8fhGfWOjvrFR39iob2zUNzbqGxv1jY36xkZ9Y6O+sVHf1KhvatQ3NeqbGvVNjfqmRn1To76pUd/UqG9q1Dc36psb9c2N+uZGfXOjvrlR39yob27UNzfqmxv1NdPUGmBaA2xrgGsNoNYA3xoQWgNia0BqDWhV2rQqbVqVNq1Km1alTavSplVp06q0aVXatCptWpW2rUrbVqVtq9K2VWnbqrRtVdq2Km1blbatSttWpV2r0q5VadeqtGtV2rUq7VqVdq1Ku1alXavSrlVpalWaWpWmVqWpVWlqVZpalaZWpalVaWpVmlqV9q1K+1alfavSvlXpprHRx9WB0T4fGONyoH8+s9/tzGG3M8fdzpx2O3Pe68xNI7+2M5vdzmx3O7Pb7cy7vQfDbu/BsNt7MOz2Hgy7vQfDbu/BuNt7MO72Hoy7vQfjbu/BuNt7MO72Hoy7vQej7D2Y3fOBl7nB6tRpv1Pn3U6dpv1ObfY7td3v1G6/U9N+p/b7nTrsd+r93o1pv3dj2u/dmGV1HS5iLYdavxx8Mdalo6OZD07hdmx231Nx46RC46Tix0kljJNKHCeVNE4qeZRU7DSNk4oZJ5VhPm3tJPy0tWneVYKbXqZyPT3te3q/7+nDvqeP+54+7Xv6vOvpzbTv6c2+p7f7nn7fd63Z911r9n3XGuG71lGaD6W7Trn86Wqdnz+LrQtpOdrG/D2ZOFIyaaRk8kDJ2GmkZMxIydiRknEjJUMjJeO7JmOWZMjZF8msj04hTM9HpxALqYfjph6Pm3o6bur5sKm76bipm+Ombo+buhs4dQpL6nlap07HTX3k3bSS+si7aSX1kXfTSuoj76aV1EfeTR+nTiPvppXUR95NK6mPvJtWUj/ubtr0BeLeqecl9ehc7Wiyy9EUqXL0zfaSvYMSSklfrtfOSV8GsPcHXwGOvKcfAuDIncUhAI7c3xwC4Mhd1iEAjtzrHQGgH7njPATAkfveQwAcufs+BMCRPcAhABIAygDCiQgBwokIAcKJCAHCiQgBwonIAAY4ESFAOBEhQDgRIUA4ESFAAkAZQDgRIUA4ESFAOBEhQDgRIUA4ERnACCciBAgnIgQIJyIEiD6wBtC6G0DyK4DYhWsAo8lz0i/SeAaIXVgGMGEXFgLELiwEiF1YCBDzQCFAAkAZQPSBQoCYBwoBYh4oBCh0IkTzTUyDn2oADS23PDVhml4cfU0mD5RMnkZKxoyUjB0pGTdSMjRSMn6kZMJIycSOyVhzuxWLtam6azz+gX9Ox009HzV1N03HTd0cN3V73NTdcVOn46buB0794e+13RSOm/rIu2kl9ZF300rqI++mj1M3I++mldRH3k0rqY+8m1ZSH3k3raQ+8m5aSf24u6kZeTc9wDc8nBl5Tz8EwJE7i0MAHLm/OQJAO3KXdQiAI/d6hwA4csd5CIAj972HAEgAKAM4sgc4BEA4ESFAOBEhQDgRIUA4ERlAByciBAgnIgQIJyIECCciBEgAKAMIJyIECCciBAgnIgQIJyIECCciA0hwIkKAcCJCgHAiQoBwIkKA6ANFN+9whF1Y9JtD57ELCwFiFxYCxC4sBIhdWAiQAFAGEPNAIUD0gUKAmAcKAWIeKAMovSO8D24+NEymAtBcjM/z0cblG8BoCgf7sHhQHynVTj2lOJ/aTPnF0dd10knW6U+yznCSdcaTrDOdZJ35HOuU3qL7MOs0J1mnPck6T9IPRTrJOk/SD0Ut/ZC3y6l9yjVHdjNC9tJCvHBNVypauqdtqWjptbaloqUz25RK0tLHbUtFS9e3LRUtPeK2VLR0lNtSIVApUNHSrTZSabsp9uM7+KWTdsKbMjxp37wpw5N22W0MH9+EK520J9+SYT5pB78pw5P2+5syPKk72JThSb3EpgwJDMUM4VPkDOFT5AzhU+QM4VPkDOFTdDyXmia4JS1KwrNpURLOUYuS8K9alCQoqURJeHktSmKioEVJzDW0KInpihYlMeNRoqTBjEeLkpjxaFESMx4tSmLGo0VJgpJKlMSMR4uSmPFoURIzHi1KYsajRUnMeJQoaTHj0aIkZjxalMSMR4uSmPFoUZKgpBIlMePRoiRmPFqUhJ88jJIPn9hDDr3rYZR8eMdzcuhdtShJUFKJkuhdtSiJ3lWLkrg+qUVJXJ/UoiT8pBIlCdcntSiJ65NalNQy46E4P9XOhGkSHH2lomVesi0VApUCFS0+flsqWjzxtlS0+MttqWjxattS0eJ7NqXitXiIbalo6cebqLQ+m/jhvevJn7IT3pjhKfvmjRkSGNYZPrw3KflT9uQbMzxlB78xw1P2+xszPKU72JjhKb3EtgzDKZ3HxgzhU+QM4VPkDOFT5AwJDMUM4VP+AcMj/OohwC1pURKeTYuScI5alIR/VaJkhIvWoiS8vBYlMVHQoiTmGlqUJCipREnMeLQoiRmPFiUx49GiJGY8WpTEjEeJkgkzHi1KYsajRUnMeLQoiRmPFiUJSipREjMeLUpixqNFScx4tCiJGY8WJTHjUaJkxoxHi5KY8WhREjMeLUrCTx5GycfPUMjoXQ+j5OM7JWb0rjqU9BN6Vy1KonfVoiR6Vy1K4vqkFiUJSipREn5Si5K4PqlFSVyf1KJk1xkPufTxGTcF/1hJ424Hu3TLw5jSMmmZZFG6nfgi2PdV5jOs0kynWKU5xSrtKVbpTrFK0rFKv+w6PhRW6U+xynCKVUYlq4zT0gzm9SqV9D6VVSrpfR6v0irpffxiX8Lk1qtU0vtUVqmk96msUknvc7dKY9arpFOsUknvE6KZ80jTepVKep/KKpX0PpVVKul9QvJzHpnWq1TS+zxepVPS+1RWqaT3idM8j40mrVeppPeprFJJ71NZJZ1ilUp6n7tVPl1Ieb1KJb1PZZVKep/KKpX0PjHP+2WaCvulkt7n8SpJSe9TWaWW3ufxKpX0Pmn59EmF/ZKU9D6VVdIpVqmk96msUknvk9ycRyK7XqWS3qeySiW9T2WVSnqfx6v0Snqfu1X69aTSK+l9KqtU0vtkE58PzgXn5ZX0PpVV0ilWqaT3qaxSSe+T3Xw1KNP6+qVX0vtUVqmk96msUknv83iVQUnvk5fv4eWw/vQJSnqfyiq19D6PV6ml93m8SlK3yrieVAYtvc/jVSrpfczk56+OmimsvVdQ0v1U16mk/6muU0kHVFtnHLcHuv2a0VCMlXU6N82JOGdu3+22xbTdFOaLSG66+ya4m3zp6DjNPFy86yOfjr4yHLfDOg7Dcfu34zActzs8DkMCQzHDcTvb4zAct28+DsNxe/LjMBy33z8Ow3G9xGEYJvgUOUP4FDlD+BQ5Q/gUOUMCQzFD+BQ5Q/gUOUP4FDlD+BQ5Q/gUMcMMnyJnCJ8iZwifImcInyJnSGAoZgifImcInyJnCJ8iZwifImd4Up9i5/vMO3N3V/oywxRouRd8yHf3dy/eC57iNOtD0dy+xekuSC7Ew3RSV/OOxE/qgd6R+Ekd0zsSP6m/ekfiBOKdiZ/Uu70j8ZM6vXckflJf+I7ET+oi35E4PGdn4gM/iUorcXjO3sThOXsTh+fsTZxAvDNxeM7exOE5exNHP7458RwX4nePSJ6JD/xEraMSv90yl5K1a+LoVUTErwwJDMUM0U/IGaJD+AcMx3javVme02etsfcHX5XEtFuLkpiia1ESbkCJkgM/hxBKtimJqwlalITz16IkJgpalCQoqURJTFe0KIkZjxYlMePRoiRmPFqUxIxHiZIDP28ZSrYpiRmPFiUx49GiJGY8WpQkKKlEScx4tCiJGY8WJTHj0aIkZjxalMSMR4mSHjMeLUpixqNFScx4tCiJGY8WJQlKKlESLuQwSlp3U5L8ayUDOp7DKBnN/BNa+yKNZyXR8WhREh2PFiUJSipREle1tCiJq1palMRVLS1Kwk9qURJXtZQoGXFVS4uSWmY8ZBclieILJa/r1DIBqa1Ty3ygtk46yTq1eMvaOrU4r9o6tfiS2jq1dO21dWrpaSvrTGo6Pj/N6/TGVDq+dEl27souJf2iK7tSUXOFbFMqaq42bUpFzZWbTakQqBSoqLmisCkVNdP5TamomXRvSkXN1LiNyuO7Lyc1E9gtqeST9rYVKiftbStUTtrbVqictLetUCFQKVA5aW9boXLS3rZC5aS9bYUKetsSlZP2tgf4TUicTtphH0Kbk/b5h9DmpG7jENqc1PMcQhuCNsNqc1L/dwhtTupCD6HNSb3wIbQ5qSM/hDaYCwyrjcFcYFxtMBcYVxvMBcbVBnOBcbUhaDOsNpgLjKsN5gLjaoO5wLjaYC4wrjaYCwyrjcVcYFxtMBcYVxvMBcbVBnOBcbUhaDOsNpgLjKsN5gLjagN/M+qd1aNDnzbqHdEu/wfaDKsNQZthtUGfNq426NPG1QbXb8bVBtdvxtUG/mZYbQjXb8bVBtdvxtVGy1zAL3fncmGiijaWaIFC6e7csZRI9vMaTb5PJH0nqMW9vx9BAkEhQS1O+P0IavGr70dQi6t8P4JavN/7EdTi0N6NoNfiozzZG0FfIUjOzEeTi+ae4BWKFgOzKRQ1zmFLKGrMwJZQCFDWUNS07FtCUdOFbwlFTWO9JRQ1vfKWUNS0vxtCCehoC1DQ0RagoKMtQEFHW4BCgLKGgo62AAUdbQEKOtoCFHS0BSjoaNdQ1DwLfVMo6GgLUM7Z0dINyuWfeyiFU192o/nUybgVwXO2v1sSJBAUEjxnY70lwXN24VsSPGfLviXBc/b3WxI8pxnYkGA6p3PYkuA5bcaWBOFJqgQTuYWgjyuC8CRSggSCQoLwJHWCYTl1imFFEJ5EShCeREoQnqROMJv51Pnu1DNBeBIhwQxPIiUIT9JEcO1JMjyJlCA8iZQgaSSYKwTNRPMvncz08gLm+mB/u/+gt4ZWBFV6km0J2uWR9t6GVT+YVXqSjQkut3Xwzq18cVbpSboSVOlJtiXo4nywp7v7sM4EVXqSbQlSnLP2fnr9OZgmlZ5kY4Ih3AjGFUGVnmRbgiHO/aCPptI8xuDmrGNIboVbpYEZF7dKtzMubgLunrjho7rihunqihsObWPcef66R4zGrHDDznXFDe/XE7eBUdwWd7R+we3yCjdcZVfccJVdccNVCnBfCRIICgnC+0kJws5JCcKhSQnCdEkJwkcJCap5ovr7EYTbkRKEgakSvJjqmWDytjYNeThaVfPA8YPgJuDuiRvWqCtu+KiuuGG6uuKGQ9sY98PrNGoeTX8M3A7erytuGMVtcT++TuPgKrvihqvsiVvP0xjfA/eVIIyilCC8n5QgGl4hQZ1PwutKEG2plCB2EilB7CRSghgMSgliLxYS1PkMr64EsRfXCAazJBJMWP2iWefTwTYmONGNYFoRxCBHSpBAUEgQHXWVoDVxweFX98bQ+USzjWsw+xvB9U6CjlpKEFfPpQThSYQER34K25TfInjNfGAvUMl84B68kvm79b53d30uZ26m5T1hzG2Z7unul6ujyc69AdEtDZtLx7qlj3BkXxx7JUIg8oqIB5FXRAKIvCISQeQVkQQir4hkEHlJ5P2eezUsEQMir4hYEHlFBD3rayKkhMj9besrRNLNjyeKd0fHXPTj88Fkpzs3XjjU3u7mbu3dXYztd8eUtHTDR2Ctpc8+AmstHfwRWGvxBkdgrcV1HIB11uJnjsBai1M6AmstHuwIrLW4uyOwJrDuxhq+sR9r+MZ+rOEb+7GGb+zHGr6xF+s8wTf2Yw3f2I81fGM/1vCN/VgTWHdjDd/YjzV8Yz/W8I39WMM39mMN39iNtYFv7McavrEfawLr7Vhbd2NNfsUafciGrKOZf25mo3Mr1uhD+rFGH9KNtUUf0o81+pB+rDG/7sca8+t+rAmsu7HG/Lofa8yv+7Hu6hv9NN9F0Xg3PWbt/KwLmbsH/BTvUxPy8jQgf3esL6oS5sX5O3ZPx155JPB4wSODxz2Pvs/eOQAPAx4veFjweMHDgccLHgQeL3h48HjBI5yNh18aX39/W+jisWaKy33gpnS7/ayd6Z2um92U3ul6303pDdIpP+VCg3Sp11wG6RCvuQzSnV1zGaQzuuZCA+UySEdwzWWQ3fiayyB72zWXvjvF7bbCIebHO0W6nHCeo4V49yl9Cbxmno+aed8npm2auTls5vawmbvDZk6HzdwfNvMwbua0XBcJeVpnHg+b+cB7aCXzgffQx5mHgffQSuYD76GVzAfeQyuZD7yHVjIfeA+tZD7wHlrJ/LB7aBh4D12GeenFlxeK34p4r985hIF38kPwG7ifOAK/OHBXcwh+A/dWh+A3cId3CH4D95mH4EfgJ+I3cM99CH4Dd/6H4Af/IeMH/yHjB/8h4pfgP2T84D9k/OA/ZPzgP2T8CPxE/OA/ZPzgP2T84D9k/OA/ZPzgP0T8MvyHjB/8h4wf/IeMH/yHjB+Bn4gf+r8Kv4f3njTThA24AvDhTVguALEDCwFiCxYCxB4sBIhNWAgQU0AhQIwBhQDRBwoBYhAoBIhJoAygEfaBwcUFoEsvAH4/v9v5/LTz+f3O5w87nz/ufP608/nzvueX3sK9en6z8/l3fv/and+/duf3r8OgoLJBuGk+1jpDqw3CYVAgBIhBgRAgAaAMIAYFQoAYFAgBYlAgBIhBQQWgzXYBOK2vuDkMCmQACZcshQDhRIQA4USEAOFEhAAJAGUA4USEAOFEhADhRIQA0UjLAPa9Xav2h7VVfLPHUwg7wsZjCDvCxvPrO8LGA+w7wsYT7PvBDniEfUfYeIZ9vz474CH2HWHjKfYdYRNg94MNB9kRNhxkR9hwkB1hw0F2hA0H2Q92hIPsCBumpiPsd9sgg6/AviG5KHP3IObiA56d87M0zhtzt85SIgf5RmRMEGdccTLEGVacNEGcccUxEGdccSzEGVccB3HGFYcgzrDfSEse4owrToA444qDCcHA4mBCMLA4mBCMK07GhGBgcTAhGFgcTAgGFgcTgoHFgQkdVhwzqWkIpjkR50yuiOMmO1O5zLRuN5crX9I+xiTOTGraB0ipptmAlGpaE0hJkFKLlGp6Ukip5jIKpFRz0UW/lDVfqeYSDaRUc0Hn9FIaTHvUSIlpjxopMe1RIyWmPWqkJEipRUpMe9RIiWmPGikxItAipYUZ+QdS0iJOyFNFHIp5fvzd5T/vzv38+DtjYRq2Rp7M8oZI1hSQo7nfHLn1C3JHBeQE5L2Ro1nujhxNbXfkuNTYHTn6/e7IcemuN3KHS2ybI5/yrS+3BeRwn92Rw312Rw732R05AXlv5HCf3ZHDfXZHDvfZHTncZ3fkcJ+9kRPcZ3fkcJ/dkXftWBzN2Vw+0dJj5D7kOQsf77C8pWacIZowTZWjrVku2FtrUwXiQX7y0/epzZByTykTpNQiZYaUSqT0E6TUIqWBlFqktJBSi5QOUh5FysrXmD1BSi1SekipRUpMe9RIiWmPGikx7VEjJaY9WqQMmPaokRLTHjVSYtqjRkqClFqk1NL2eLuc2qdck9Itv3K25OxBpKzMYKOWtgdSRi1tD6SMWtoeSBm1XOSClJEgpRYptVzkgpRRy0WuE0hZ8ZVRy0UuSBm1XOSClBHTHi1SJkx71EiJaY8aKTHtUSMlpj1qpCRIqUVKTHvUSIkRgRYps7DtIZpPH/zkagQ1/oAqOxAUEiQQFBL0ICgkGEBQSDCCoJBgAkEhwQyCon7QThMICgkaEBQShCeREoQnkRIkEBQShCeREoQnkRKEJ5EShCcREjToqKUEhTuJo/mmw4FMlaDCr+da6WOnQdBEEBQSTCAoJJhBUEbQTiAoJGhAUEjQgqCsH5Q+yBwEpc8lB0ELTyIlCE8iJQhPIiUITyIlCE8iJOjgSaQE4UmkBNFRCwlSkeBlefMLvHza3fcYYsR4RkxgxERGTGLE5PaY8jOBKjGGEWMZMYw68Iw68Iw68Iw68Iw68Iw68Iw6CIw6CIw6CIw6CIw6CIw6CIw6CIw6CIw6CIw6CIw6iIw6iIw6iIw6iIw6iIw6iIw6iIw6iIw6iIw6iIw6SIw6SIw6SIw6SIw6SIw6SIw6SIw6SIw6SIw6SIw6yIw6yIw6yIw6yIw6yIw6yIw6yIw6yIw6yIw6yO114KaJEWMYMZYR4xgxxIjxjJjAiImMmMSIYdSBYdSBYdSBYdSBYdSBYdSBYdSBYdSBYdSBYdSBYdSBZdSBZdSBZdSBZdSBZdSBZdSBZdSBZdSBZdSBZdSBY9SBY9SBY9SBY9SBY9SBY9SBY9SBY9SBY9SBY9QBMeqAGHVAjDpgzBMdY57oGPNEx5gnOsY80THmiY4xT3SMeaJjzBMdY57oGPNEx5gnusZ5YmGWHkN8Ptal+2sA8fkFwt4vEPd+gbT3C+SdX6BxYMp4AbP3C9i9X8Dt/QK09wuI38mJ3PICPq5fIOz9AnHvF0g7v8Abk+I4+fkV4t03Qy8NwnOY44URL8zzwsryJ7uEJVcKi7ywxAvLrLA3JsjVMMMLs7ywcpWkKS9h1hbCiBfmeWGBFxZ5YYkXlllhb8yXq2GGF2Z5YbwqeeMuPsu3Kry9fdo9f/fBvXHfmscxuTmG3rg3yeMYw4ixjBjHiCFGjGfEBEZMZMSU6yBMc0ww65jcHvPGL2ofx5TrYLlbZDB2HWMZMY4RQ4wYz4gJjJjIiEmMmNwe88avuR7HMOrAMurAMuqgPC+00cwf2fbFF+DmqOIrmbDcY9WEtH4/lGeG1SjPigqsqMiKKtaeiXH+4DIx+3VU5kSV54fVKMOKsqwox4oiVpRnRQVWVGRFsWqDWLXhWbXhWbXhWbXhWbXhWbVRni6abGbHbbItRAVWVGRFJU5UeRwVp/lTPt59ypv0HOMYMUXql91gjqG8jvHlmHlBMbh1TJF4TPMGFHNcx0RGTJF2uvvudoFBLsfMZjn5sIopfzMwLc8OT4Xcyt8MvMXkgj5lJ2+mZec2U0ir6ikb+WpU+R1olmIwxq/3xbKNr0YFVlRkRSVWVPnT2QS/RKU1w7I5fnKYcxRN69cqfw+rGuVZUYEVVSbv7cLQ+2kdlVhRmRHlyx6+GmVYUZYV5VhRxIryrKjAioqsqDdqY/k4ND7bdVTmRJmJFWVYUZYV5VhRxIryrKiyyu7Wxzhn1lGJFZU5UWXXXo0yrCjLinKsKGJFeVZUYEWxasOyasO+URsUl6iw/rRxEyvKsKIsK8qxoogV5VlRgRUVGf2Gf2PaUovKnKg3pi2VqLKjcTbP/aFz7q4/LF3svTTkZmnInX/d/PuyAdr2JdL+L5F3f4myG9v2Jcz+L2H3fwm3/0sUP5HcZd4/v8RlaHP/Et+j/BtR5mFU+T14uWb2MCqyohIrKnOiyo41umXyQatpvS9fBM7LPV6z9+sYy4hxjBhixHjGDMO/4W5rUZEVlVhRmREV3nC3tSjDirKsKMeKIlaUZ0UFVlRkRSVWFKs2yj714adFKLvUvMyKsy3EtL/zQ/nKcOV1IiMmMWJye0zZYz5mYA0jxjJiGPpYYsR4RkxgxJTrwM91naNdxyRGTG6PKfvJSoxhxFhGjGPE1OqgFMOoA8eog7KDrMQkRkxujyHG5wExPg+I8XlAjM8DYnweEKMOiFEHxKgDYtQBNdbBfy9/+t8fv3368afPv/5xiXj6y7++/Pznp69fnv/45//9Pv/NT98+ff786bcffv/29edff/nr268/fP7689PffZie//Xvy0TCfbz4Zrpk8yShCx8pPGV2/Ut7+aOxZJ7+x1MhXS5IXY4O3l/yuOTy/w==",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==",
      "debug_symbols": "bY9dCoMwEITvss8+ZG39qVeRIlFXCYREYlIowbs3aaVNW1+GneXbYcfDSL2bO6EmvULTepB64FZoFZzfMuiNkFLMXboGFgVPT35duIp2tdxYaIpzBqRGaMo8XE9C0mv8A5Gxut5ZZIjFG8eSHfJYVR/+Un7x1y3YGzeC95L21yenhqSJvS/0U2oxeqDRGYr1kmZBWyyynIXYEP0A",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "_finish_transfer_to_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7176719043052132708": {
            "error_kind": "string",
            "string": "Function _finish_transfer_to_public can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_finish_transfer_to_public"
      ]
    },
    {
      "name": "mint",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6515419266667913063": {
            "error_kind": "string",
            "string": "zero token ID not supported"
          },
          "9296579303138805202": {
            "error_kind": "string",
            "string": "token already exists"
          }
        },
        "parameters": [
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "mint"
      ]
    },
    {
      "name": "public_get_symbol",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15009911310769716579": {
            "error_kind": "string",
            "string": "Function public_get_symbol can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "compressed_string::field_compressed_string::FieldCompressedString"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBFJgAABAMmAgEEACYCAgQAHxgAAgABgEQkAAAARSQAAABGLQQAAYBEJwIAAgSARCYCAwQBOg0AAgADJSQAAACSHgIAAQAeAgACADI4AAEAAgADJgIBAQEjAgADAAAAbyQAAAC7HgIAAQkmAgIAAQo4AQIDIwIAAwAAAIskAAAAzS4MAAIAASUnAIAEBHgADQAAAIAEgAMjAIADAAAAuikBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEF0E3qz6yL/WM7AQECJS0AGMoYyg==",
      "debug_symbols": "vZXbjoIwEIbfpddcdA49+SobY1CrISFgEDfZGN99WwMVXaJZFveGUPLN/D8zzcxZbP36tF8V1a4+isXHWZT1Jm+Lugqn8yUT66Yoy2K/Gn4WMj6MuvLHQ17F47HNm1YsQGvMhK+28dVgyLArSi8WOrz+hKVUPSxRJRhwjGZm09HMSifawQhsKaW2hDCEl5mwcgbvNsHB/D96n6PuDKnu+lXdQelEazDPvTtyPeyY+MG7o1m9g7z3HhXsuxVCxd4uAfBnCe1kf+O0Q3rRNZkyO2nVQ9cAfvvHMQhhStAUJeIpQW4sCC3aLggtm+clJsW9AulhF81YjQFtGnY0oFGO5TZkqaMNS37ePgNpFhm8HxgjPkAS3S6fvhtGy0s4feZNka9L362A3anaDDZC+3XwD8vh0NQbvz01Pq6J24aAOGXRZITXSxQOQZhU0Ag63w==",
      "brillig_names": [
        "public_get_symbol"
      ]
    },
    {
      "name": "get_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "10055739771636044368": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBFJgAABAMmAgEEACYCAgQAHxgAAgABgEQkAAAARSQAAABGLQQAAYBEJwIAAgSARCYCAwQBOg0AAgADJSQAAACbHgIAAQAeAgACADI4AAEAAgADJgIBAQEjAgADAAAAbyQAAADEHgIAAQkmAgIAAQo4AQIDIwIAAwAAAIskAAAA1iYCAQAFLgwAAQACLAwCASUnAIAEBHgADQAAAIAEgAMjAIADAAAAwykBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEFi40qC3IiUlA7AQECJS0AGMoYyg==",
      "debug_symbols": "5ZXBbsIwDIbfJece4thxEl5lmlCBgCpVLSpl0oR49yWoBOgqqnVll12quPps/7GT+CQ2fnXcLYtqWx/E4u0kynqdt0VdBet0zsSqKcqy2C3vfwsZP0Zf+MM+r6J5aPOmFQtgVpnw1SYujQoRtkXpxYLD8jsspb7CUukEgxqiich0NJHmRDsYgC2m0BYV3MPvmbByBu02wUH8H2qfo+4Eqe48VnfQnGgG81y7Q3eFHSH1tDucVTvIR+0xg311hlCxl6cA+HUKdvJ64tgpHOmaTJGdtLrXNYCf7jg6KZjiNCUT0hQnN+SEkqhzQsljXQxBUhf5dtbBDNEGLXa0IUnPG2IgvS5GPT4BQzok4u04Mff7R/RP9noO1kfeFPmq9N0A2x6r9d08az/3vjfa9k299ptj4+OQu803iDNCuQzpcgWCgTpDE3KEPF8=",
      "brillig_names": [
        "get_admin"
      ]
    },
    {
      "name": "transfer_in_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "1433889167918961673": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 17
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954044801249163952": {
            "error_kind": "string",
            "string": "NFT not found when transferring"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "get_notes_internal",
        "get_collapse_hints",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "private_get_name",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2111772463301017956": {
            "error_kind": "string",
            "string": "Function private_get_name can only be called statically"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "_store_payload_in_transient_storage_unsafe",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16958085610837407363": {
            "error_kind": "string",
            "string": "Function _store_payload_in_transient_storage_unsafe can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [
          {
            "name": "slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "point",
            "type": {
              "fields": [
                {
                  "name": "x",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "y",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "is_infinite",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ],
              "kind": "struct",
              "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
            },
            "visibility": "private"
          },
          {
            "name": "setup_log",
            "type": {
              "kind": "array",
              "length": 9,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBRJgAABAMmAgYEDSYCBwQAHxgABwAGgEQdAIBHgEcBLQiARAABLQiARQACLQiARgADLQiARwAEJwIABQSASCYCBwQJLAgBBiYCCAQKABABCAEmAwYEAQAoBgIILQQABYADLQQACIAELQQAB4AFJAAAAJ0sDAYFJAAAAOMkAAAA6ycCAAEEgFEmAgIEADoNAAEAAgEAgAOABYAHLQCAA4AILQCABIAJCwCACIAHgAojAIAKAAAA4i0BgAiABi0CgAaACQEAgAgAAoAIAQCACQACgAkiAAAAsSUnAIBDBAADJSQAAAOCLAgBBwAAAQIBJgIIAQAsDggHLAgBBwAAAQIBJgIIAAAsDggHLAgBBwAAAQIBJgIJAAIsDgkHHgIABwAeAgAJADI4AAcACQAKJgIHAQEjAgAKAAABSiQAAAOrHgIABwEeAgAJAAo4BwkKIwIACgAAAWYkAAADvRwMBAcALAgBBCYCCQQEABABCQEmAwQEAQAoBAIJLAwJCiwOAgoAKAoCCiwOAwoAKAoCCiwOBwomAgIEASYCAwQALAwDBiIAAAGwDSgABoBDAAcjAgAHAAADPyIAAAHFJgIGAAMAOAEGBywIAQEmAgYECgAQAQYBJgMBBAEAKAECBiwMBgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJACgJAgksDggJLAgBBgAAAQIBLA4BBiYCAQQJLAwDBCIAAAJSDDgEAQgjAgAIAAACxyIAAAJkLA0GBSwMAwQiAAACcQw4BAEDIwIAAwAAAoQiAAACgyUcDAQDAAA4BwMGJgIIBAkMOAQICSMCAAkAAAKlJAAAA88AKAUCCAA4CAQJLA0JAy8MAAMABgA4BAIDLAwDBCIAAAJxJgIJBAkMOAQJCiMCAAoAAALeJAAAA88AKAUCCQA4CQQKLA0KCCwNBgkmAgsECQw4BAsMIwIADAAAAwckAAADzy0EAAmAAycAgAQEAAokAAAD4S0IgAUACgAoCgILADgLBAwsDggMLA4KBgA4BAIILAwIBCIAAAJSHAwGBwAAOAEHCSYCCgQDDDgGCgsjAgALAAADYCQAAAPPACgEAgoAOAoGCywNCwcvDAAHAAkAOAYCBywMBwYiAAABsCcAgAQEeAANAAAAgASAAyMAgAMAAAOqKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQXrVzkD6KB2gzsBAQIlKQEAAQXonQn+oREtDjsBAQIlLQGAA4AGCwCABgACgAcjAIAHAAAD/CIAAAQHLQCAA4AFIgAABG4tAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAAEWi0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAAEKScBgAUEAAEDAIAGAAKABiIAAARuJS0AGMoYyg==",
      "debug_symbols": "1ZvdTuswDMffpde9iGM7tnmVI4QGDDRp2tAYRzpCvPtJx5bBPooopXNvpnazl1//aWwnbV6r++nty+PNbPGwfK6u/rxW8+XdZD1bLvLZ61td3a5m8/ns8ebj11VoPiKFjcPz02TRnD+vJ6t1dQUpxbqaLu6bQ4n5Lx5m82l1leLbdZ2dqIuTdXDiLi2xdnBKsYuTdHCSLi1J6uCkXTpXuYOTdWnJvtu59bFxCLwzDpGLMcRT1kQkW2siTsXa4ISxYvlrxQgfjTfw1gO8FuNMPxw8hj6UJyjKp6+UB07FOoG0wxvaztgI6RAeYq/wED7Db5qQX28i8q83geHHTVCKuybyoX1100ksN53KYb/hz6+4zzHQJfMhdQiOyNjF6WQSUyQr1yShXS1Rwa2xqGK7WjkYhTKebT/oovEJ6zxCtsZI8ZNtw55wxOwyXvbTlcVI2Eesu45Ydx2x7gYjZufRslMII2anEbPbeNmxjxiJqbCztrMLE+2Mmfig+qPTNZkSlJKRBA9qMjpTk7U7nSuGDIsTUI+dFjXt+iGq7i88zzjeecQXz7mi5WI8zvRRZ/qoM33OFQEX42FXPHwuWV+Mh5zxmC8e8JUvGNQXT/QVDzn6ioeMvuIhY/LFQ87iITnLF+QsHrKzfMHO4qGz+QU7m1+wOIuH4iwe2tDjy5LueCzZIU+CgfN7fkpU1i2C0BFP7CM+97ZwkYgGxkmluySJHuHY0DiMLTg8uDplhSwf2hGOucJJvtTpZeWnRxxxhaO+1FFf6vSy6vMtHLSCY6HdGABo/2YPfM5AG3pxQ59xBIYukcz2KTccpVyB5IsnOtMnmi8eJGc8zvQhZ/qQDl1i454H9YiHfZX8wuKLJznTR4IzHvbFo+CMR33xGDrjMVc8GsgZjzN9wNf9o+ArXyj28V5cb2tEeu4J0O/htK0R5b4YGqdtJquUXOGwL3XYXOGcW0G7FI4vdcSXOqJD4/S4RqRKbuiv3/LZ38lqNrmdT7d7Sh9eFncftpiu/z1ND3abPq2Wd9P7l9W02Xe633LazB1ArY4Q8mU2mTxqjZqPYfOTUA1izSlsLEMNGjNBpvgP",
      "brillig_names": [
        "_store_payload_in_transient_storage_unsafe"
      ]
    },
    {
      "name": "set_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          }
        },
        "parameters": [
          {
            "name": "new_admin",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBFJgAABAMmAgIEASYCAwQAHxgAAwACgEQtCIBEAAEkAAAARSQAAABGJwIAAQSARSYCAgQAOg0AAQACJSQAAACYHgIAAgAeAgADADI4AAIAAwAEJgICAQEjAgAEAAAAbyQAAADBJgICAAUuDAACAAMeAgAEAQo4AwQFIwIABQAAAJEkAAAA0y8MAAEAAiUnAIAEBHgADQAAAIAEgAMjAIADAAAAwCkBAAEF96Hzr6Wt1Mo7AQECJSkBAAEFvh4//z6k9vo7AQECJSkBAAEFedUGXr5zdNI7AQECJS0AGMoYyg==",
      "debug_symbols": "5VXbjoIwEP2XPvPQudBp/ZXNxqCiISFgEDfZGP99i4GCSmxidF98IR1yhnNm5tA5qU2+Ou6WRbWtD2rxdVJlvc7aoq58dDonatUUZVnsltPXSncPSS/4wz6ruvDQZk2rFmAMJiqvNt1R0H9hW5S5Whh/vAdrnQ5gjWkAA86hmVl6NHNqAtrBDNhS+LQlhCn4O1FWv0C7DWAv/h+1v6LvDKHvJtZ3SE1AG5DH2h25AeyY+Ea7o5dqB32tvWOw72bwHXs7BcAcBWp2fRZqIxEKIBcozDgIkDm0kKUeLaz58YwFgvUFr/05p0MTjbUac2MJL+5zakWcr1Uo1Orgca1scLCOP7rYTSIYbhIrd3Ik2nrHUzldEuETSayfSZq96RBoaABCqiPOIAwDIXYxZ1gyw7BtaiPOMMF0YpyOOQN4XBdg6WoUZx/9ZE2Rrcq837vbY7WerOH2d5/fbOR9U6/zzbHJu908rmXoOo02Ibr8XD4gSch5Ds/zBw==",
      "brillig_names": [
        "set_admin"
      ]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8861757336002045335": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 99
          },
          "9862881900111276825": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 35
          }
        },
        "parameters": [
          {
            "name": "log_plaintext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "get_private_nfts",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "page_index",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "kind": "array",
                "length": 10,
                "type": {
                  "kind": "field"
                }
              },
              {
                "kind": "boolean"
              }
            ],
            "kind": "tuple"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_private_nfts"
      ]
    },
    {
      "name": "prepare_private_balance_increase",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "random",
        "decompose_hint",
        "field_less_than",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "transfer_to_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "random",
        "decompose_hint",
        "field_less_than",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "10055739771636044368": {
            "error_kind": "string",
            "string": "Function get_admin can only be called statically"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "10536464181608181124": {
            "error_kind": "string",
            "string": "transfer not prepared"
          },
          "10846690067871036662": {
            "error_kind": "string",
            "string": "invalid owner"
          },
          "11859452850824495745": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 60
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15009911310769716579": {
            "error_kind": "string",
            "string": "Function public_get_symbol can only be called statically"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16958085610837407363": {
            "error_kind": "string",
            "string": "Function _store_payload_in_transient_storage_unsafe can only be called internally"
          },
          "17028138060491915576": {
            "error_kind": "string",
            "string": "Function _finalize_transfer_to_private_unsafe can only be called internally"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18105278452957613314": {
            "error_kind": "string",
            "string": "Function public_get_name can only be called statically"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "364657447181031001": {
            "error_kind": "string",
            "string": "invalid admin"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5527120278801020911": {
            "error_kind": "string",
            "string": "invalid NFT owner"
          },
          "6515419266667913063": {
            "error_kind": "string",
            "string": "zero token ID not supported"
          },
          "7176719043052132708": {
            "error_kind": "string",
            "string": "Function _finish_transfer_to_public can only be called internally"
          },
          "8778930052620580050": {
            "error_kind": "string",
            "string": "caller is not an admin"
          },
          "9296579303138805202": {
            "error_kind": "string",
            "string": "token already exists"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "9443383425599897888": {
            "error_kind": "string",
            "string": "Function owner_of can only be called statically"
          },
          "9605075991997100073": {
            "error_kind": "string",
            "string": "token does not exist"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBMJgAABAMmAgIEASYCAwQAHxgAAwACgEstCIBLAAEkAAAARSQAAADMJwIAAQSATCYCAgQAOg0AAQACJwCAQwQAAygAgEQAO5rKACcAgEUEAA0nAIBGAAABKACARwBH2s1zKwCASAAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACsAgEkAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAqAIBKAAAAAAAAAAABAAAAAAAAAAAlJAAAIiEoAgACANx37RMKOAECAyYCBAQAJgIGBAMAOAQGBSwIAQIAEAEFASYDAgQBACgCAgUsDgQFACgFAgUsDgQFJgIFBAMAOAIFBCYCBAEAJgIFAAMmAgYBASYCBwAAJgIIAAYmAgkABSYCCgQAJgILBAEjAgADAAABTSIAAAWDJgINBD8sCAEOJgIPBEAAEAEPASYDDgQBACgOAg8fPAALAA0ADywNDg0AKA0CDSwODQ4sCAENAAABAgEsCAEPAAABAgEAKA4CEQA4EQoSLA0SECwODg0sDgsPJgIRBBIsCAASLAwNEywMDxQsDAgVABAAEQAkAAAiSiwEAAAsDBMOLA0OEQAoEQIRLA4RDiYCEgQTLAgAEywMDRQsDA8VLAwIFgAQABIAJAAAIkosBAAALAwUESwNEQ0AKA0CDSwODREsCAENAAABAgEsDgQNLAgBDwAAAQIBLA4HDywIARIAAAECASYCEwDaLA4TEh4CABQANTgAFAAVABYAIwIAFgAAAmMiAAACViwMBAMsDAcMIgAAAnAsDAYDLAwVDCIAAAJwIwIAAwAAAoEmAhcEADsJARc1OAAUAAMAFwIjAgAXAAACpCIAAAKXLAwEFSwMBxYiAAACsSwMBhUsDAMWIgAAArEjAgAVAAACwiYCFAQAOwkBFCwIARQmAhUEAgAQARUBJgMUBAEAKBQCFR88AAoACwAVLA0UFQAoFQIVLA4VFAAoFAIXADgXChgsDRgVHAwVFwQcDBcUACYCFwQYLAgAGCwMBBksDAcaLAwTGwAQABcAJAAAJJ0sBAAALAwZFSYCEwANLAgBFyYCGAQEABABGAEmAxcEAQAoFwIYLAwYGSwOExkAKBkCGSwOFBkAKBkCGSwOFRksDRcTACgTAhMsDhMXKgIAEwAAAAAAAAAAAwAAAAAAAAAAJgIaBBssCAAbLAwTHAAQABoAJAAAN84sBAAALAwcFCwMHRUsDB4YLAwfGSwNFBMAKBMCEywOExQsCAETAAABAgEsDhQTLA0VFAAoFAIULA4UFSwIARQAAAECASwOFRQsCAEVAAABAgEsDhgVLAgBGAAAAQIBLA4ZGCwMCgMiAAAECQ0oAAOAQwAZIwIAGQAAIbEiAAAEHiYCFwQZLAgAGSwMExosDBQbLAwVHCwMGB0AEAAXACQAADh1LAQAACwMGgMKOBYDEyMCABMAAARbJAAAOPkKOAwHAx4CABMBCjgMExQSOAMUDCMCAAwAAAR8JAAAOQsKOBAHAwo4AwQMIwIADAAABJMkAAA5HSYCAwQTLAgAEywMDRQsDA8VLAwSFiwMCRcsDBAYABAAAwAkAAA5LywEAAAmAgwEEywIABMsDA4ULAwGFQAQAAwAJAAAOTssBAAALAwUAyYCDAQTLAgAEywMDRQsDA8VLAwSFiwMBRcsDAMYABAADAAkAAA6MSwEAAAmAgwEEywIABMsDBEULAwGFQAQAAwAJAAAOTssBAAALAwUAyYCDAQTLAgAEywMDRQsDA8VLAwSFi0IgEYAFywMAxgAEAAMACQAADoxLAQAAB4CAAMAMwIAAwAoAgINLA0NDCYCDgQCADgNDgM6DQADAAwiAAAFgygCAAMAli3rAgo4AQMMLA0CAwAoAwIDLA4DAiwNAgMAKAMCAywOAwIsDQIDACgDAgMsDgMCLA0CAwAoAwIDLA4DAiwNAgMAKAMCAywOAwIsDQIDACgDAgMsDgMCIwIADAAABewiAAAHSywIAQMmAgwEAgAQAQwBJgMDBAEAKAMCDB88AAsACwAMLA0DDAAoDAIMLA4MAywIAQwAAAECASwOAwwsCAEDAAABAgEsDgoDJgIOBA8sCAAPLAwMECwMAxEAEAAOACQAADtOLAQAACwMEA0AKA0CDAA4DAoOLA0OAywIAQwAAAECASwOBAwsCAENAAABAgEsDgcNLAgBDgAAAQIBJgIPANksDg8OJgIPBBAsCAAQLAwMESwMDRIsDA4TABAADwAkAAA7ySwEAAAmAhAEESwIABEsDAwSLAwNEywMDhQsDAkVABAAEAAkAAA78ywEAAAsDBIPHgIAEAEKOA8QESMCABEAAAb1JAAAPAMmAg8EECwIABAsDAwRLAwNEiwMDhMsDAkULAwDFQAQAA8AJAAAOS8sBAAALA0CAwAoAwIDLA4DAgAoAgINLA0NDCYCDgQCADgNDgM6DQADAAwiAAAHSygCAAMA6v/ysQo4AQMMJgIDAAcmAg0ABCYCDgBNJgIPBAImAhAACCYCEQBPJgISABEjAgAMAAAHiSIAAAnNLAgBDCYCEwQDABABEwEmAwwEAQAoDAITHzwACwAPABMsDQwTACgTAhMsDhMMLAgBEwAAAQIBLA4MEywIAQwAAAECASwOCgwmAhUEFiwIABYsDBMXLAwMGCwMDRkAEAAVACQAADwVLAQAACwMFxQmAhYEFywIABcsDBMYLAwMGSwMEhoAEAAWACQAADy5LAQAACwMGBUsCAEMAAABAgEsDgQMLAgBEwAAAQIBLA4HEywIARYAAAECASYCFwDULA4XFiYCFwQYLAgAGCwMDBksDBMaLAwWGwAQABcAJAAAO8ksBAAACjgVBxcKOBcEGCMCABgAAAiEJAAAPV0mAhsEHCwIABwsDAwdLAwTHiwMFh8sDAMgLAwOISwMFSIAEAAbACQAAD1vLAQAACwMHRcsDB4YLAwfGSwMIBomAhwEHSwIAB0sDBceLAwYHywMGSAsDBohABAAHAAkAAA+dSwEAAAsDB4bCjgbBBcjAgAXAAAJACQAAD6UJgIbBBwsCAAcLAwMHSwMEx4sDBYfLAwDICwMDiEsDBUiABAAGwAkAAA9bywEAAAsDB0XLAweGCwMHxksDCAaLwiARgAaJgIeBB8sCAAfLAwMICwMEyEsDBYiLAwQIywMESQsDBUlABAAHgAkAAA+piwEAAAsDCAaLAwhGywMIhwsDCMdJgIMBB4sCAAeLAwaHywMGyAsDBwhLAwdIiwMFCMAEAAMACQAADkvLAQAAAAoAgIULA0UEyYCFQQCADgUFQw6DQAMABMiAAAJzSgCAAwAyLvXtAo4AQwTIwIAEwAACegiAAAKtiwIAQwAAAECASwOBAwsCAETAAABAgEsDgcTLAgBFAAAAQIBJgIVANMsDhUUJgIVBBYsCAAWLAwMFywMExgsDBQZABAAFQAkAAA7ySwEAAAeAgAMCQsoAAyARgATIwIAEwAAClEkAAA/rC4MAAUADCYCFAQBJgIWBAMAOBQWFSwIARMAEAEVASYDEwQBACgTAhUsDhQVACgVAhUsDhQVJgIVBAMAOBMVFCwMFBUsDgwVACgTAhUsDRUUJgIWBAIAOBUWDDoNAAwAFCIAAAq2KAIADADN5d9JCjgBDBMjAgATAAAK0SIAAAufLAgBDAAAAQIBLA4EDCwIARMAAAECASwOBxMsCAEUAAABAgEmAhUAziwOFRQmAhUEFiwIABYsDAwXLAwTGCwMFBkAEAAVACQAADvJLAQAAB4CAAwJCygADIBGABMjAgATAAALOiQAAD++LgiARgAMJgIUBAEmAhYEAwA4FBYVLAgBEwAQARUBJgMTBAEAKBMCFSwOFBUAKBUCFSwOFBUmAhUEAwA4ExUULAwUFSwODBUAKBMCFSwNFRQmAhYEAgA4FRYMOg0ADAAUIgAAC58oAgAMACsRsZoKOAEMEyMCABMAAAu6IgAADK0sCAEMAAABAgEsDgQMLAgBEwAAAQIBLA4HEywIARQAAAECASYCFQDLLA4VFCYCFQQWLAgAFiwMDBcsDBMYLAwUGQAQABUAJAAAO8ksBAAAHgIAFQkLKAAVgEYAFiMCABYAAAwjJAAAP9AmAhYEFywIABcsDAwYLAwTGSwMFBosDAkbABAAFgAkAAA78ywEAAAsDBgVJgITBAEmAhYEAwA4ExYULAgBDAAQARQBJgMMBAEAKAwCFCwOExQAKBQCFCwOExQmAhQEAwA4DBQTLAwTFCwOFRQAKAwCFSwNFRQmAhYEAgA4FRYTOg0AEwAUIgAADK0oAgAMAIUydvEKOAEMEyMCABMAAAzIIgAAEqEmAgwEBCwIARMmAhQEBQAQARQBJgMTBAEAKBMCFB88AAsADAAULA0TFAAoFAIULA4UEywIARQAAAECASwOExQsCAETAAABAgEsDgoTJgIWBBcsCAAXLAwUGCwMExksDA0aABAAFgAkAAA/4iwEAAAsDBgVJgIXBBgsCAAYLAwUGSwMExosDA0bABAAFwAkAAA/4iwEAAAsDBkWJgIYBBksCAAZLAwUGiwMExssDBIcABAAGAAkAABAhiwEAAAsDBoXJgIZBBosCAAaLAwUGywMExwsDBIdABAAGQAkAABAhiwEAAAsDBsYLAgBEwAAAQIBLA4EEywIARQAAAECASwOBxQsCAEZAAABAgEmAhoAsSwOGhkmAhoEGywIABssDBMcLAwUHSwMGR4AEAAaACQAADvJLAQAAB4CABoBCjgVGhsjAgAbAAARxSIAAA4WLA0TGiwNFBssDRkcHgIAHQEsCAEeJgIfBAIAEAEfASYDHgQBACgeAh8fPAAKAAsAHywNHh8AKB8CHywOHx4AKB4CIAA4IAohLA0hHxwMHyAEHAwgHgAmAiAEISwIACEsDBoiLAwbIywMHCQAEAAgACQAACSdLAQAACwMIh8mAhoALSwIARsmAhwEBQAQARwBJgMbBAEAKBsCHCwMHCAsDhogACggAiAsDh0gACggAiAsDh4gACggAiAsDh8gLA0bGgAoGgIaLA4aGyoCABoAAAAAAAAAAAQAAAAAAAAAACYCIAQhLAgAISwMGiIAEAAgACQAADfOLAQAACwMIhwsDCMdLAwkHiwMJR8sDRwaACgaAhosDhocLAgBGgAAAQIBLA4cGiwNHRwAKBwCHCwOHB0sCAEcAAABAgEsDh0cLAgBHQAAAQIBLA4eHSwIAR4AAAECASwOHx4sDAoYIgAAD3cMOBgMHyMCAB8AABFVIgAAD4kmAhgEHywIAB8sDBogLAwcISwMHSIsDB4jABAAGAAkAAA4dSwEAAAsDCAMKAIAGAAnFrFmJgIbBAMmAh0EAwA4Gx0cLAgBGgAQARwBJgMaBAEAKBoCHCwOGxwAKBwCHCwOGxwmAhwEAwA4GhwbLAwbHCwOGBwAKBwCHCwOFRwAKBwCHCwODBwsDRoMACgMAgwsDgwaLAgBDCYCGAQDABABGAEmAwwEAQAoDAIYLAwYGy0KgEgAGwAoGwIbLQqASAAbACgMAhgAKBoCHSwNHRwmAh4EAgA4HR4bOAOlABiARgAbABwAHSACAAwsCAEaACgaAh4sDR4cJgIfBAIAOB4fGyE8AAoADAAbLAwMHCYCHwQDADgcHx4AEAEeASYDGgQBACgaAh8sDhwfACgfAh8sDhwfLAwcGAYoGAIYLA0aDAAoDAIMLA4MGiMCAB0AABD7IgAAEN8AKBoCHCwNHBsmAh0EAgA4HB0MOw0MGyIAABD7CjgYCwwjAgAMAAARDSQAAEEqACgaAhgsDRgYDDgKGBsjAgAbAAARKCQAAEE8JgIbBAMAOBobGAA4GAobLA0bDAsoAAyARwAYIwIAGAAAEVAkAABBTiIAABHcIwIAHwAAEWIiAAARtyYCIAQEDDgYICEjAgAhAAAReSQAAEE8ACgbAiAAOCAYISwNIR8mAiAEISwIACEsDBoiLAwcIywMHSQsDB4lLAwfJgAQACAAJAAAQWAsBAAAIgAAEbcAOBgLHywMHxgiAAAPdwo4GAcMIwIADAAAEdckAABCjyIAABHcJgIcBB0sCAAdLAwTHiwMFB8sDBkgLAwQISwMESIsDBcjABAAHAAkAAA+piwEAAAsDB4MLAwfGCwMIBosDCEbJgIUBBwsCAAcLAwMHSwMGB4sDBofLAwbIAAQABQAJAAAO/MsBAAALAwdEwo4ExUUIwIAFAAAElgkAABCoSYCEwQcLAgAHCwMDB0sDBgeLAwaHywMGyAsDBYhABAAEwAkAAA5LywEAAAAKAICFCwNFBMmAhUEAgA4FBUMOg0ADAATIgAAEqEoAgAMADGaV1EKOAEMEyMCABMAABK8IgAAFoksCAETJgIUBA4AEAEUASYDEwQBACgTAhQfLAALgEUAFCwNExQAKBQCFCwOFBMsCAEUAAABAgEsCAEVAAABAgEAKBMCFwA4FwoYLA0YFiwOExQsDgsVLAgBEyYCFwQEABABFwEmAxMEAQAoEwIXLAwXGCwOBxgAKBgCGCwOBxgAKBgCGCwOBxgsCAEXAAABAgEsDhMXLAwKDCIAABNZDSgADIBDABMjAgATAAAhGiIAABNuLA0UEywNFRgBKAAYgEMAGQ44GBkaIwIAGgAAE5AkAABCsywOExQsDhkVLA0XEwAoEwIYADgYChksDRkXACgTAhkAOBkLGiwNGhgAKBMCGgA4Gg8bLA0bGRwMGRoBHAwaEwAsCAEZJgIaBAoAEAEaASYDGQQBACgZAhosDBobLA4HGwAoGwIbLA4HGwAoGwIbLA4HGwAoGwIbLA4HGwAoGwIbLA4HGwAoGwIbLA4HGwAoGwIbLA4HGwAoGwIbLA4HGwAoGwIbLA4HGywIARoAAAECASwOGRomAhkECSwMCgwiAAAUUww4DBkbIwIAGwAAIIMiAAAUZSwNFBssDRUcADgcGR0OOBwdHiMCAB4AABSEJAAAQrMsDhsULA4dFSwNGhQsDRQVACgVAhUsDhUULAgBFQAAAQIBLA4UFSwIARQAAAECASwOChQsCAEaJgIbBAoAEAEbASYDGgQBACgaAhssDBscLA4HHAAoHAIcLA4HHAAoHAIcLA4HHAAoHAIcLA4HHAAoHAIcLA4HHAAoHAIcLA4HHAAoHAIcLA4HHAAoHAIcLA4HHAAoHAIcLA4HHCYCHAQdLAgAHSwMFR4sDBQfLAwSICwMGiEAEAAcACQAAELFLAQAACwMHhssDRsUACgUAhQsDhQbLAgBFAAAAQIBLA4EFCwIARUAAAECASwOBxUsCAEcAAABAgEmAh0AoCwOHRwmAh0EHiwIAB4sDBQfLAwVICwMHCEAEAAdACQAADvJLAQAAB4CABQBHgIAFQAKOBQVHCMCABwAABXCJAAARBYsCAEUJgIVBAQAEAEVASYDFAQBACgUAhUsDBUcLA4XHAAoHAIcLA4YHAAoHAIcLA4THCwMCgwiAAAV/Q0oAAyAQwATIwIAEwAAIEAiAAAWEgA4FgUTLA0aFAAoFAIULA4UGiwIARQAAAECASwOGhQsDAoMIgAAFjoMOAwZFSMCABUAAB/IIgAAFkwsDRQVLAwKDCIAABZZDDgMGRQjAgAUAAAfhSIAABZrACgCAhQsDRQTJgIVBAIAOBQVDDoNAAwAEyIAABaJKAIADAAh6+X4CjgBDBMmAgwASyMCABMAABapIgAAGE0sCAETJgIUBAMAEAEUASYDEwQBACgTAhQfPAALAA8AFCwNExQAKBQCFCwOFBMsCAEUAAABAgEsDhMULAgBEwAAAQIBLA4KEyYCFgQXLAgAFywMFBgsDBMZLAwSGgAQABYAJAAAPLksBAAALAwYFSYCFwQYLAgAGCwMFBksDBMaLAwSGwAQABcAJAAAPLksBAAALAwZFiwIARMAAAECASwOBBMsCAEUAAABAgEsDgcULAgBFwAAAQIBJgIYAJ8sDhgXJgIYBBksCAAZLAwTGiwMFBssDBccABAAGAAkAAA7ySwEAAAeAgAYASYCGQQaLAgAGiwMGBssDBUcLAwWHSwMEx4sDBQfLAwXICwMEyEsDBQiLAwXIy0IgEYAJCwMEyUsDBQmLAwXJywMBSgsDBMpLAwUKiwMFyssDAksLAwTLSwMFC4sDBcvLAwIMCwMDDEsDBMyLAwUMywMFzQsDAM1LAwONiwMEzcsDBQ4LAwXOSwMEDosDBE7ABAAGQAkAABEKCwEAAAAKAICFSwNFRQmAhYEAgA4FRYTOg0AEwAUIgAAGE0oAgATACICtDsKOAETFCMCABQAABhoIgAAGlQsCAETJgIUBAQAEAEUASYDEwQBACgTAhQfLAALgEMAFCwNExQAKBQCFCwOFBMsCAEUAAABAgEsDhMULAgBEwAAAQIBLA4KEyYCFgQXLAgAFywMFBgsDBMZABAAFgAkAABPMCwEAAAsDBgVACgVAhcAOBcKGCwNGBYmAhcEGCwIABgsDBQZLAwTGiwMEhsAEAAXACQAAE+rLAQAACwMGRUmAhgEGSwIABksDBQaLAwTGywMEhwAEAAYACQAAE+rLAQAACwMGhcsCAETAAABAgEsDgQTLAgBFAAAAQIBLA4HFCwIARgAAAECASYCGQBxLA4ZGCYCGQQaLAgAGiwMExssDBQcLAwYHQAQABkAJAAAO8ksBAAAHgIAGQEeAgAaAAo4GRobIwIAGwAAGZkkAABQTyYCGQQaLAgAGiwMFhssDBUcLAwXHSwMEx4sDBQfLAwYICwMEyEsDBQiLAwYIy0IgEYAJCwMEyUsDBQmLAwYJywMBSgsDBMpLAwUKiwMGCssDAksLAwTLSwMFC4sDBgvLAwIMCwMDDEsDBMyLAwUMywMGDQsDAM1LAwONiwMEzcsDBQ4LAwYOSwMEDosDBE7ABAAGQAkAABEKCwEAAAAKAICCSwNCQgmAgwEAgA4CQwFOg0ABQAIIgAAGlQoAgAFACV4SRQKOAEFCCMCAAgAABpvIgAAG/csCAEFJgIIBAMAEAEIASYDBQQBACgFAggfPAALAA8ACCwNBQgAKAgCCCwOCAUsCAEIAAABAgEsDgUILAgBBQAAAQIBLA4KBSYCDAQTLAgAEywMCBQsDAUVLAwNFgAQAAwAJAAAPBUsBAAALAwUCSYCDQQTLAgAEywMCBQsDAUVLAwSFgAQAA0AJAAAPLksBAAALAwUDCwIAQUAAAECASwOBAUsCAEIAAABAgEsDgcILAgBDQAAAQIBJgIPAGIsDg8NJgIPBBIsCAASLAwFEywMCBQsDA0VABAADwAkAAA7ySwEAAAeAgAPAR4CABIACjgPEhMjAgATAAAbbyQAAFBhJgIVBBYsCAAWLAwFFywMCBgsDA0ZLAwQGiwMERssDAwcABAAFQAkAAA+piwEAAAsDBcPLAwYEiwMGRMsDBoUJgIFBBUsCAAVLAwPFiwMEhcsDBMYLAwUGSwMCRoAEAAFACQAADkvLAQAAAAoAgIJLA0JCCYCDAQCADgJDAU6DQAFAAgiAAAb9ygCAAIA+EEIDQo4AQIFIwIABQAAHBIiAAAeMywIAQEmAgIEAgAQAQIBJgMBBAEAKAECAh88AAsACwACLA0BAgAoAgICLA4CASwIAQIAAAECASwOAQIsCAEBAAABAgEsDgoBJgIIBBIsCAASLAwCEywMARQAEAAIACQAADtOLAQAACwMEwUAKAUCAgA4AgoILA0IASwIAQIAAAECASwOBAIsCAEFAAABAgEsDgcFLAgBBwAAAQIBJgIIADEsDggHJgIIBBIsCAASLAwCEywMBRQsDAcVABAACAAkAAA7ySwEAAAeAgAICQsoAAiARgAJIwIACQAAHPMkAABQcyYCDwQSLAgAEiwMAhMsDAUULAwHFSwMAxYsDA4XLAwBGAAQAA8AJAAAPW8sBAAALAwTCCwMFAksDBUMLAwWDSYCDgQSLAgAEiwMCBMsDAkULAwMFSwMDRYAEAAOACQAAD51LAQAACwMEwMjAgADAAAdaiQAAFCFJgINBBIsCAASLAwCEywMBRQsDAcVLAwQFiwMERcsDAEYABAADQAkAAA+piwEAAAsDBMDLAwUCCwMFQksDBYMJgICBA0sCAANLAwDDiwMCA8sDAkQLAwMEQAQAAIAJAAAO/MsBAAALAwOASYCAwQBJgIHBAMAOAMHBSwIAQIAEAEFASYDAgQBACgCAgUsDgMFACgFAgUsDgMFJgIFBAMAOAIFAywMAwUsDgEFACgCAgUsDQUDJgIHBAIAOAUHAToNAAEAAyIAAB4zJgIBAnMmAgICVSYCAwJlJgIFAm4mAgcCbCYCCAJrJgIJAmMmAgsCbyYCDAJ0JgINAncmAg4CciYCDwIgLAgBECYCEQQRABABEQEmAxAEAQAoEAIRLAwREiwOAhIAKBICEiwOBRIAKBICEiwOCBIAKBICEiwOBRIAKBICEiwOCxIAKBICEiwODRIAKBICEiwOBRIAKBICEiwODxIAKBICEiwOARIAKBICEiwOAxIAKBICEiwOBxIAKBICEiwOAxIAKBICEiwOCRIAKBICEiwODBIAKBICEiwOCxIAKBICEiwODhIKOAQGASMCAAEAAB+EJgICBBIsCAEDJgIFBBIAEAEFASwMAwUpAwAFBeWPmFkHMWKQACgFAgUAKBACByYCCAQQLQQAB4ADLQQABYAELQQACIAFJAAAUJcmAgcEEAA4BQcFLA4KBQAoBQIFOw0DAiUcDAwUAAA4ExQWJgIXBAkMOAwXGCMCABgAAB+mJAAAQTwAKBUCFwA4FwwYLA0YFC8MABQAFgA4DAsULAwUDCIAABZZJgIWBAkMOAwWFyMCABcAAB/fJAAAQTwAKBsCFgA4FgwXLA0XFSwNFBYmAhgECQw4DBgaIwIAGgAAIAgkAABBPC0EABaAAycAgAQEAAokAABQ3S0IgAUAFwAoFwIYADgYDBosDhUaLA4XFAA4DAsVLAwVDCIAABY6HAwMEwAAOBYTFSYCFwQDDDgMFxgjAgAYAAAgYSQAAEE8ACgUAhcAOBcMGCwNGBMvDAATABUAOAwLEywMEwwiAAAV/SwNGhssDRQcLA0VHQA4HQweDjgdHh8jAgAfAAAgpiQAAEKzJgIfBA0MOB4fICMCACAAACC9JAAAQTwAKBwCHwA4Hx4gLA0gHSYCHgQJDDgMHh8jAgAfAAAg4iQAAEE8LQQAG4ADJwCABAQACiQAAFDdLQiABQAcACgcAh4AOB4MHywOHR8sDhwaADgMCxssDBsMIgAAFFMsDRcTLA0UGCwNFRkAOBkMGg44GRobIwIAGwAAIT0kAABCsyYCGwQNDDgaGxwjAgAcAAAhVCQAAEE8ACgYAhsAOBsaHCwNHBkmAhoEAww4DBobIwIAGwAAIXkkAABBPC0EABOAAycAgAQEAAQkAABQ3S0IgAUAGAAoGAIaADgaDBssDhkbLA4YFwA4DAsTLAwTDCIAABNZIwIAGQAAIb4iAAAiEyYCGgQDDDgDGhsjAgAbAAAh1SQAAEE8ACgXAhoAOBoDGywNGxkmAhoEGywIABssDBMcLAwUHSwMFR4sDBgfLAwZIAAQABoAJAAAQWAsBAAAIgAAIhMAOAMLGSwMGQMiAAAECScAgAQEeAANAAAAgASAAyMAgAMAACJJKQEAAQX3ofOvpa3UyjsBAQIlJAAAIiEmAgUAACwIAQYmAgcEIAAQAQcBJgMGBAEAKAYCByYCCAQfADgIBwgsDAcJDDgJCAoWDAoKIwIACgAAIpksDgUJACgJAgkiAAAieiwIAQUAAAECASwOBgUmAgYEHyYCBwQBJgIIBAAsDAgEIgAAIr4MOAQGAyMCAAMAACQGIgAAItAsDQEELA0CCQA4CQYKDjgJCgsjAgALAAAi7yQAAEKzLA4EASwOCgIsDQUBJgICAgAsCAEEJgIFBCAAEAEFASYDBAQBACgEAgUmAgkEHwA4CQUJLAwFCgw4CgkLFgwLCyMCAAsAACNFLA4CCgAoCgIKIgAAIyYsCAECAAABAgEsDgQCLAwIAyIAACNbDDgDBgQjAgAEAAAjfyIAACNtLA0CASwNAQIAKAICAiwOAgElLA0CBCYCCAQfDDgDCAkjAgAJAAAjmiQAAEE8ACgBAggAOAgDCSwNCQUcDAUJAhwMCQgAHAwIBQImAgkEHww4AwkKIwIACgAAI84kAABBPC0EAASAAycAgAQEACAkAABQ3S0IgAUACAAoCAIJADgJAwosDgUKLA4IAgA4AwcELAwEAyIAACNbLA0FAywNAQksDQIKADgKBAsOOAoLDCMCAAwAACQpJAAAQrMmAgwEPww4CwwNIwIADQAAJEAkAABBPAAoCQIMADgMCw0sDQ0KJgILBB8MOAQLDCMCAAwAACRlJAAAQTwtBAADgAMnAIAEBAAgJAAAUN0tCIAFAAkAKAkCCwA4CwQMLA4KDCwOCQUAOAQHAywMAwQiAAAiviQAACIhLAgBBAAAAQIBLA4BBCwIAQUAAAECASwOAgUjAgABAAA3ySIAACTJJgICADEKOAMCBiYCAgQAKgIABwAAAAAAAAAAAgAAAAAAAAAAJgIIACwmAgkEASYCCgQCIwIABgAANigiAAAlCSYCBgBiCjgDBgsqAgAGAAAAAAAAAAADAAAAAAAAAAAjAgALAAA0ciIAACU1JgILAHEKOAMLDCYCCwQEIwIADAAAMoYiAAAlUSYCDACWCjgDDA0mAgwAACMCAA0AADJ9IgAAJW0mAg0Anwo4Aw0OIwIADgAAMMciAAAlhCYCDQCgCjgDDQ4jAgAOAAAuXCIAACWbJgINALEKOAMNDiMCAA4AACxeIgAAJbImAgsAywo4AwsNIwIADQAALDoiAAAlySYCCwDOCjgDCw0jAgANAAAsFiIAACXgJgILANMKOAMLDSMCAA0AACvyIgAAJfcmAgsA1Ao4AwsMIwIADAAAKjwiAAAmDiYCBgDZCjgDBgsjAgALAAAorSIAACYlJgIHANoKOAMHCiMCAAoAACZAJgILBAA7CQELJgIDBD8sCAEHJgIKBEAAEAEKASYDBwQBACgHAgofPAAJAAMACiwIAQomAgsEQQAQAQsBJgMKBAEAKAoCCyYCDARAADgMCwwsDAsNDDgNDA4WDA4OIwIADgAAJqosDggNACgNAg0iAAAmiywIAQgAAAECASwOCggsDAIGIgAAJsAMOAYDCiMCAAoAACg1IgAAJtIsDQgGLA0GBwAoBwIHLA4HBioCAAcAAAAAAAAAAEAAAAAAAAAAACYCDQQOLAgADiwMBw8AEAANACQAADfOLAQAACwMDwgsDBAKLAwRCywMEgwsDQgHACgHAgcsDgcILAgBBwAAAQIBLA4IBywNCggAKAgCCCwOCAosCAEIAAABAgEsDgoILAgBCgAAAQIBLA4LCiwIAQsAAAECASwODAsmAgwEQCwMAgMiAAAnfww4AwwCIwIAAgAAJ8UiAAAnkSYCAwQMLAgADCwMBw0sDAgOLAwKDywMCxAAEAADACQAADh1LAQAACwMDQIsDAIBIgAAN0cjAgACAAAn0iIAACgnJgINBEAMOAMNDiMCAA4AACfpJAAAQTwAKAYCDQA4DQMOLA0OAiYCDQQOLAgADiwMBw8sDAgQLAwKESwMCxIsDAITABAADQAkAABBYCwEAAAiAAAoJwA4AwkCLAwCAyIAACd/LA0ICgA4BgkLJgINBD8MOAYNDiMCAA4AAChVJAAAQTwAKAcCDQA4DQYOLA0ODCYCDgRADDgLDg8jAgAPAAAoeiQAAEE8LQQACoADJwCABAQAQSQAAFDdLQiABQANACgNAg4AOA4LDywODA8sDg0ILAwLBiIAACbALAgBBiYCCwQCABABCwEmAwYEAQAoBgILHzwACQAJAAsAKAYCDAA4DAINLA0NCywIAQYmAgwEAwAQAQwBJgMGBAEAKAYCDCwMDA0sDggNACgNAg0sDgsNJgIOBA8sCAAPLAwHEAAQAA4AJAAAN84sBAAALAwQCCwMEQssDBIMLAwTDSwNCAcAKAcCBywOBwgsCAEHAAABAgEsDggHLA0LCAAoCAIILA4ICywIAQgAAAECASwOCwgsCAELAAABAgEsDgwLLAgBDAAAAQIBLA4NDCwMAgMiAAAphgw4AwoCIwIAAgAAKcwiAAApmCYCAwQNLAgADSwMBw4sDAgPLAwLECwMDBEAEAADACQAADh1LAQAACwMDgIsDAIBIgAAN0cjAgACAAAp2SIAACouJgINBAIMOAMNDiMCAA4AACnwJAAAQTwAKAYCDQA4DQMOLA0OAiYCDQQOLAgADiwMBw8sDAgQLAwLESwMDBIsDAITABAADQAkAABBYCwEAAAiAAAqLgA4AwkCLAwCAyIAACmGLAgBByYCCwQDABABCwEmAwcEAQAoBwILHzwACQAKAAsAKAcCCwA4CwIMLA0MCgAoBwIMADgMCQ0sDQ0LLAgBByYCDAQEABABDAEmAwcEAQAoBwIMLAwMDSwOCA0AKA0CDSwOCg0AKA0CDSwOCw0sDQcIACgIAggsDggHJgINBA4sCAAOLAwGDwAQAA0AJAAAN84sBAAALAwPCCwMEAosDBELLAwSDCwNCAYAKAYCBiwOBggsCAEGAAABAgEsDggGLA0KCAAoCAIILA4ICiwIAQgAAAECASwOCggsCAEKAAABAgEsDgsKLAgBCwAAAQIBLA4MCywMAgMiAAArOQ0oAAOAQwACIwIAAgAAK4IiAAArTiYCAwQMLAgADCwMBg0sDAgOLAwKDywMCxAAEAADACQAADh1LAQAACwMDQIsDAIBIgAAN0cjAgACAAArjyIAACvkJgIMBAMMOAMMDSMCAA0AACumJAAAQTwAKAcCDAA4DAMNLA0NAiYCDAQNLAgADSwMBg4sDAgPLAwKECwMCxEsDAISABAADAAkAABBYCwEAAAiAAAr5AA4AwkCLAwCAyIAACs5LAgBAwAAAQIBJgMDBAEAKAMCBh88AAkAAgAGLAwMASIAADdHLAgBAwAAAQIBJgMDBAEAKAMCBh88AAkAAgAGLAwMASIAADdHLAgBAwAAAQIBJgMDBAEAKAMCBh88AAkAAgAGLAwMASIAADdHLAgBBiYCBwQFABABBwEmAwYEAQAoBgIHHzwACQALAAcsDQYHACgHAgcsDgcGACgGAgsAOAsCDCwNDAcAKAYCDAA4DAkNLA0NCwAoBgINADgNCg4sDQ4MACgGAg0BKAANgEMADiwNDgosCAEGJgINBAYAEAENASYDBgQBACgGAg0sDA0OLA4IDgAoDgIOLA4HDgAoDgIOLA4LDgAoDgIOLA4MDgAoDgIOLA4KDioCAAcAAAAAAAAAAAUAAAAAAAAAACYCDQQOLAgADiwMBw8AEAANACQAADfOLAQAACwMDwgsDBAKLAwRCywMEgwsDQgHACgHAgcsDgcILAgBBwAAAQIBLA4IBywNCggAKAgCCCwOCAosCAEIAAABAgEsDgoILAgBCgAAAQIBLA4LCiwIAQsAAAECASwODAsmAgwEBSwMAgMiAAAtpgw4AwwCIwIAAgAALewiAAAtuCYCAwQMLAgADCwMBw0sDAgOLAwKDywMCxAAEAADACQAADh1LAQAACwMDQIsDAIBIgAAN0cjAgACAAAt+SIAAC5OJgINBAUMOAMNDiMCAA4AAC4QJAAAQTwAKAYCDQA4DQMOLA0OAiYCDQQOLAgADiwMBw8sDAgQLAwKESwMCxIsDAITABAADQAkAABBYCwEAAAiAAAuTgA4AwkCLAwCAyIAAC2mLAgBBiYCBwQOABABBwEmAwYEAQAoBgIHHywACYBFAAcsCAEHJgIKBA8AEAEKASYDBwQBACgHAgomAgsEDgA4CwoLLAwKDAw4DAsNFgwNDSMCAA0AAC7BLA4IDAAoDAIMIgAALqIsCAEIAAABAgEsDgcILAwCAyIAAC7XDSgAA4BFAAcjAgAHAAAwTyIAAC7sLA0IBiwNBgcAKAcCBywOBwYqAgAHAAAAAAAAAAAOAAAAAAAAAAAmAg0EDiwIAA4sDAcPABAADQAkAAA3ziwEAAAsDA8ILAwQCiwMEQssDBIMLA0IBwAoBwIHLA4HCCwIAQcAAAECASwOCAcsDQoIACgIAggsDggKLAgBCAAAAQIBLA4KCCwIAQoAAAECASwOCwosCAELAAABAgEsDgwLJgIMBA4sDAIDIgAAL5kMOAMMAiMCAAIAAC/fIgAAL6smAgMEDCwIAAwsDAcNLAwIDiwMCg8sDAsQABAAAwAkAAA4dSwEAAAsDA0CLAwCASIAADdHIwIAAgAAL+wiAAAwQSYCDQQODDgDDQ4jAgAOAAAwAyQAAEE8ACgGAg0AOA0DDiwNDgImAg0EDiwIAA4sDAcPLAwIECwMChEsDAsSLAwCEwAQAA0AJAAAQWAsBAAAIgAAMEEAOAMJAiwMAgMiAAAvmSwNCAcAOAMJCiYCDAQNDDgDDA0jAgANAAAwbyQAAEE8ACgGAgwAOAwDDSwNDQsmAg0EDgw4Cg0OIwIADgAAMJQkAABBPC0EAAeAAycAgAQEAA8kAABQ3S0IgAUADAAoDAINADgNCg4sDgsOLA4MCCwMCgMiAAAu1ywIAQcmAgsEAwAQAQsBJgMHBAEAKAcCCx88AAkACgALACgHAgsAOAsCDCwNDAoAKAcCDAA4DAkNLA0NCywIAQcmAgwEBAAQAQwBJgMHBAEAKAcCDCwMDA0sDggNACgNAg0sDgoNACgNAg0sDgsNLA0HCAAoCAIILA4IByYCDQQOLAgADiwMBg8AEAANACQAADfOLAQAACwMDwgsDBAKLAwRCywMEgwsDQgGACgGAgYsDgYILAgBBgAAAQIBLA4IBiwNCggAKAgCCCwOCAosCAEIAAABAgEsDgoILAgBCgAAAQIBLA4LCiwIAQsAAAECASwODAssDAIDIgAAMcQNKAADgEMAAiMCAAIAADINIgAAMdkmAgMEDCwIAAwsDAYNLAwIDiwMCg8sDAsQABAAAwAkAAA4dSwEAAAsDA0CLAwCASIAADdHIwIAAgAAMhoiAAAybyYCDAQDDDgDDA0jAgANAAAyMSQAAEE8ACgHAgwAOAwDDSwNDQImAgwEDSwIAA0sDAYOLAwIDywMChAsDAsRLAwCEgAQAAwAJAAAQWAsBAAAIgAAMm8AOAMJAiwMAgMiAAAxxCwMDAEiAAA3RywIAQYmAgcEBAAQAQcBJgMGBAEAKAYCBx8sAAmAQwAHLA0GBwAoBwIHLA4HBgAoBgIMADgMAg0sDQ0HACgGAg0AOA0JDiwNDgwAKAYCDgA4DgoPLA0PDSwIAQYmAgoEBQAQAQoBJgMGBAEAKAYCCiwMCg4sDggOACgOAg4sDgcOACgOAg4sDgwOACgOAg4sDg0OLA0GBwAoBwIHLA4HBioCAAcAAAAAAAAAAAQAAAAAAAAAACYCDgQPLAgADywMBxAAEAAOACQAADfOLAQAACwMEAgsDBEKLAwSDCwMEw0sDQgHACgHAgcsDgcILAgBBwAAAQIBLA4IBywNCggAKAgCCCwOCAosCAEIAAABAgEsDgoILAgBCgAAAQIBLA4MCiwIAQwAAAECASwODQwsDAIDIgAAM7wMOAMLAiMCAAIAADQCIgAAM84mAgMEDSwIAA0sDAcOLAwIDywMChAsDAwRABAAAwAkAAA4dSwEAAAsDA4CLAwCASIAADdHIwIAAgAANA8iAAA0ZCYCDQQEDDgDDQ4jAgAOAAA0JiQAAEE8ACgGAg0AOA0DDiwNDgImAg0EDiwIAA4sDAcPLAwIECwMChEsDAwSLAwCEwAQAA0AJAAAQWAsBAAAIgAANGQAOAMJAiwMAgMiAAAzvCwIAQcmAgsEAwAQAQsBJgMHBAEAKAcCCx88AAkACgALACgHAgsAOAsCDCwNDAoAKAcCDAA4DAkNLA0NCywIAQcmAgwEBAAQAQwBJgMHBAEAKAcCDCwMDA0sDggNACgNAg0sDgoNACgNAg0sDgsNLA0HCAAoCAIILA4IByYCDQQOLAgADiwMBg8AEAANACQAADfOLAQAACwMDwgsDBAKLAwRCywMEgwsDQgGACgGAgYsDgYILAgBBgAAAQIBLA4IBiwNCggAKAgCCCwOCAosCAEIAAABAgEsDgoILAgBCgAAAQIBLA4LCiwIAQsAAAECASwODAssDAIDIgAANW8NKAADgEMAAiMCAAIAADW4IgAANYQmAgMEDCwIAAwsDAYNLAwIDiwMCg8sDAsQABAAAwAkAAA4dSwEAAAsDA0CLAwCASIAADdHIwIAAgAANcUiAAA2GiYCDAQDDDgDDA0jAgANAAA13CQAAEE8ACgHAgwAOAwDDSwNDQImAgwEDSwIAA0sDAYOLAwIDywMChAsDAsRLAwCEgAQAAwAJAAAQWAsBAAAIgAANhoAOAMJAiwMAgMiAAA1bywIAQYmAgsEAgAQAQsBJgMGBAEAKAYCCx88AAkACQALACgGAgwAOAwCDSwNDQssCAEGJgIMBAMAEAEMASYDBgQBACgGAgwsDAwNLA4IDQAoDQINLA4LDSYCDgQPLAgADywMBxAAEAAOACQAADfOLAQAACwMEAgsDBELLAwSDCwMEw0sDQgHACgHAgcsDgcILAgBBwAAAQIBLA4IBywNCwgAKAgCCCwOCAssCAEIAAABAgEsDgsILAgBCwAAAQIBLA4MCywIAQwAAAECASwODQwsDAIDIgAANwEMOAMKAiMCAAIAADdZIgAANxMmAgMEDSwIAA0sDAcOLAwIDywMCxAsDAwRABAAAwAkAAA4dSwEAAAsDA4CLAwCASIAADdHJgICAQEsDgIELA4BBSIAADfJIwIAAgAAN2YiAAA3uyYCDQQCDDgDDQ4jAgAOAAA3fSQAAEE8ACgGAg0AOA0DDiwNDgImAg0EDiwIAA4sDAcPLAwIECwMCxEsDAwSLAwCEwAQAA0AJAAAQWAsBAAAIgAAN7sAOAMJAiwMAgMiAAA3ASwNBQElJAAAIiEmAgIAACwIAQMmAgQEBAAQAQQBJgMDBAEAKAMCBCwMBAUsDgIFACgFAgUsDgIFACgFAgUsDgIFLA0DBAAoBAIELA4EAywIAQQmAgUEBQAQAQUBJgMEBAEAKAQCBSwMBQYsDgIGACgGAgYsDgIGACgGAgYsDgIGACgGAgYsDgEGJgIBBAAmAgIBACwMAgUsDAEGLAwEAiwMBQQsDAMBLAwGAyUkAAAiISwNBAUmAgYBAAo4BQYHIwIABwAAOJkmAggEADsJAQgmAgUEBiwIAAYsDAEHLAwCCCwMAwksDAQKABAABQAkAABRaywEAAAsDQEFLA0CBiwNAwcsDgUBLA4GAiwOBwMmAgEBASwOAQQmAgEEAAAoBgIDADgDAQQsDQQCLAwCASUpAQABBfSAAaZZ0ydCOwEBAiUpAQABBR8AUBJAJCLuOwEBAiUpAQABBQUPhgQj7RZZOwEBAiUkAAAiIS8MAAUABCUkAAAiISwIAQQAAAECASYCBQAALA4FBCwIAQUAAAECAS0KgEYABSYCBgQBJgIHBAAnAgAIAAEAJgIJBB8sDAcDIgAAOYAMOAMJByMCAAcAADmXIgAAOZIsDQQBJSwIAQcAAAECASwOAwcjAgACAAA5sSIAADnWAjgJAwoCOAoGCw44BgoMIwIADAAAOc0kAABSyCwOCwciAAA51iwNBAosDQcLJgIMBB8MOAsMDSMCAA0AADn1JAAAQTwAKAECDAA4DAsNLA0NBxwMBwsALA0FBwQ4CwcMADgKDAssDgsEBDgHCAosDgoFADgDBgcsDAcDIgAAOYAkAAAiIQEwgEQABAAGLgwABgAHJgIIAAAKOAcICSMCAAkAADpbJAAAUtonAgAHAN6tLwwABwAGJgIKBAssCAALLQiASgAMABAACgAkAAA3ziwEAAAsDAwGLAwNBywMDggsDA8JLA0GCgAoCgIKLA4KBiwIAQoAAAECASwOBgosDQcGACgGAgYsDgYHLAgBBgAAAQIBLA4HBiwIAQcAAAECASwOCAcsCAEIAAABAgEsDgkIJgIJBAssCAALLAwKDCwMBg0sDAcOLAwIDywMBRAAEAAJACQAAEFgLAQAACYCCwQMLAgADCwMCg0sDAYOLAwHDywMCBAAEAALACQAADh1LAQAACwMDQkvDAAFAAQBKAAEgEYABS8MAAkABSUkAAAiISwNAQMsDQIEJgIGBAEMOAQGByMCAAcAADtyJAAAQTwAKAMCBgA4BgQHLA0HBSwIAQYmAgcEAgAQAQcBJgMGBAEAKAYCBywMBwgsDgUIJgIFBAEAOAQFBw44BAcIIwIACAAAO7wkAABCsywOAwEsDgcCLAwGASUkAAAiIR4CAAQAHgIABQAyOAAEAAUABiYCBAEBIwIABgAAO/IkAABS7CUkAAAiIS4MAAQABSwMBQElKQEAAQV51QZevnN00jsBAQIlJAAAIiEmAgYEBywIAAcsDAEILAwCCQAQAAYAJAAAUv4sBAAALAwIBSYCAQAECjgDAQImAgEEAAAoBQIHADgHAQgsDQgGIwIAAgAAPKsiAAA8ZyYCAQARCjgDAQIjAgACAAA8oiIAADx+JgIBAIIKOAMBAiMCAAIAADyZJgIFBAA7CQEFLAwGBCIAADy0LAwGBCIAADy0LAwGBCIAADy0LAwEASUkAAAiISYCBgQHLAgABywMAQgsDAIJABAABgAkAABS/iwEAAAsDAgFJgIBAAQKOAMBAiYCAQQAACgFAgcAOAcBCCwNCAYjAgACAAA9TyIAAD0LJgIBABEKOAMBAiMCAAIAAD1GIgAAPSImAgEAggo4AwECIwIAAgAAPT0mAgUEADsJAQUsDAYEIgAAPVgsDAYEIgAAPVgsDAYEIgAAPVgsDAQBJSkBAAEFWmtrTYh6H2c7AQECJSQAACIhJgIMBA0sCAANLAwEDiwMBg8AEAAMACQAAFN5LAQAACwMDgsmAgQASwo4BQQGJgIEAAAKOAsEDCYCBAEAIwIABgAAPj0iAAA9vSYCBgBNCjgFBg0jAgANAAA+FiIAAD3UJgIGAE8KOAUGDSMCAA0AAD3vJgIOBAA7CQEOCjgMBAUjAgAFAAA+ASQAAFT/LAwBBywMAggsDAMJLAwLCiIAAD5kCjgMBAUjAgAFAAA+KCQAAFT/LAwBBywMAggsDAMJLAwLCiIAAD5kCjgMBAUjAgAFAAA+TyQAAFT/LAwBBywMAggsDAMJLAwLCiIAAD5kLAwKBCwMBwEsDAgCLAwJAyUkAAAiIS4MAAQABRwMBQYBHAwGBAAcDAQFASwMBQElKQEAAQWBBBWe7dZF0jsBAQIlJAAAIiEmAgwEDSwIAA0sDAQOLAwGDwAQAAwAJAAAU3ksBAAALAwOCyYCBABLCjgFBAYmAgQAAAo4CwQMJgIEAQAjAgAGAAA/dCIAAD70JgIGAE0KOAUGDSMCAA0AAD9NIgAAPwsmAgYATwo4BQYNIwIADQAAPyYmAg4EADsJAQ4KOAwEBSMCAAUAAD84JAAAVP8sDAEHLAwCCCwMAwksDAsKIgAAP5sKOAwEBSMCAAUAAD9fJAAAVP8sDAEHLAwCCCwMAwksDAsKIgAAP5sKOAwEBSMCAAUAAD+GJAAAVP8sDAEHLAwCCCwMAwksDAsKIgAAP5ssDAoELAwHASwMCAIsDAkDJSkBAAEF+0Le07wSjQI7AQECJSkBAAEF0E3qz6yL/WM7AQECJSkBAAEFi40qC3IiUlA7AQECJSQAACIhJgIGBAcsCAAHLAwBCCwMAgkAEAAGACQAAFURLAQAACwMCAUmAgEABAo4AwECJgIBBAAAKAUCBwA4BwEILA0IBiMCAAIAAEB4IgAAQDQmAgEAEQo4AwECIwIAAgAAQG8iAABASyYCAQCCCjgDAQIjAgACAABAZiYCBQQAOwkBBSwMBgQiAABAgSwMBgQiAABAgSwMBgQiAABAgSwMBAElJAAAIiEmAgYEBywIAAcsDAEILAwCCQAQAAYAJAAAVREsBAAALAwIBSYCAQAECjgDAQImAgEEAAAoBQIHADgHAQgsDQgGIwIAAgAAQRwiAABA2CYCAQARCjgDAQIjAgACAABBEyIAAEDvJgIBAIIKOAMBAiMCAAIAAEEKJgIFBAA7CQEFLAwGBCIAAEElLAwGBCIAAEElLAwGBCIAAEElLAwEASUpAQABBQ0KLvL2wvvvOwEBAiUpAQABBeidCf6hES0OOwEBAiUpAQABBUSNqimioUC3OwEBAiUkAAAiISwNAwYsDQQHJgIIAQAKOAcICSMCAAkAAEGIJgIKBAA7CQEKCygABoBDAAcmAgYEASMCAAcAAEIbIgAAQaIsDQEHLA0CCCwNAwksDQQKJgIMBAMMOAkMDSMCAA0AAEHJJAAAQTwtBAAHgAMnAIAEBAAEJAAAUN0tCIAFAAsAKAsCDAA4DAkNLA4FDQA4CQYFDjgJBQcjAgAHAABCBiQAAEKzLA4LASwOCAIsDgUDLA4KBCIAAEKOJgIHBAgsCAAILAwBCSwMAgosDAMLLAwEDAAQAAcAJAAAUWssBAAALA0BBywNAggsDQQJJgIKBAAtBAAHgAMnAIAEBAAEJAAAUN0tCIAFAAsAKAsCDAA4DAoNLA4FDSwOCwEsDggCLA4GAywOCQQiAABCjiUpAQABBYydEbQ59GaQOwEBAiUpAQABBZaHLyYENfT2OwEBAiUpAQABBUWnynEZQeQVOwEBAiUkAAAiISwNBAYAKAYCBiwOBgQsCAEGAAABAgEsDgQGJgIEAAQKOAMEByYCBAARCjgDBAgmAgQEASYCCQCCJgIKBAkmAgsEACwMCwUiAABDFQw4BQoLIwIACwAAQywiAABDJywNBgElLA0GDCwNAQ0sDQIOJgIQBAkMOA4QESMCABEAAENPJAAAQTwAKA0CEAA4EA4RLA0RDwA4DgQQDjgOEBEjAgARAABDdCQAAEKzLA4NASwOEAIjAgAHAABDviIAAEOJIwIACAAAQ7UiAABDlgo4AwkNIwIADQAAQ6wmAg4EADsJAQ4sDA8LIgAAQ8csDA8LIgAAQ8csDA8LIgAAQ8cmAg4ECQw4BQ4PIwIADwAAQ94kAABBPC0EAAyAAycAgAQEAAokAABQ3S0IgAUADQAoDQIOADgOBQ8sDgsPADgFBAssDg0GLAwLBSIAAEMVKQEAAQXrVzkD6KB2gzsBAQIlJAAAIiEmAicEKCwIACgsDB0pLAweKiwMHyssDCAsLAwhLSwMAi4AEAAnACQAAD6mLAQAACwMKSMsDCokLAwrJSwMLCYmAh4EJywIACcsDCMoLAwkKSwMJSosDCYrABAAHgAkAAA78ywEAAAsDCgdCjgdAR4jAgAeAABEqSQAAFWMJgIBAAAmAh0EJywIACcsDCMoLAwkKSwMJSosDCYrLAwBLAAQAB0AJAAAOS8sBAAAJgIdAAMAOAMdHiwIAR0mAh8EBAAQAR8BJgMdBAEAKB0CHywMHyAsDgEgACggAiAsDgEgACggAiAsDgEgLAgBHwAAAQIBLA4dHyYCHQQBJgIgBAAsDCAiIgAARTUNKAAigEMABCMCAAQAAE7NIgAARUosDR8GACgGAggAOAggCSwNCQcAKAYCCQA4CR0KLA0KCCYCCQQCACgGAgsAOAsJDCwNDAocDAoLARwMCwYAHAwGCgEWDAoGCjgHAQsEOAYLDAo4CAELBDgMCw0mAgsBAAo4DQsMIwIADAAARbskAABVnisCAAwAE0HWdfoDDs4xE61TyjT9E7GbbpdiBGc09BSCTE1q3jUrAgANAA7bHik8POkb/ATjzqpQ0sVB+p0JHHLrQD77HPosszV/LAgBDiYCDwQEABABDwEmAw4EAQAoDgIPLAwPECwODRAAKBACECwODBAAKBACECwOCxAcDAINBRwMDQwAAjgCDA0JKAANgEoADxwMDxAFHAwQDQACOA8NEAkoABCASgAPBSgADYBKABAAOBAMDQUwgEkADwAMADgNDBAKOAIQDCMCAAwAAEaVJgIRBAA7CQERLAgBDCYCEAQDABABEAEmAwwEAQAoDAIQLAwQESwODREAKBECESwODxEsCAENJgIPBAQAEAEPASYDDQQBACgOAg8mAhAEAwAoDAIRJgISBAIAKA0CE0L3AA8AEQATABAAKA0CDgA4DiAPLA0PDAAoDQIPADgPHRAsDRAOACgNAhAAOBAJESwNEQ8cDA8NARwMDQkAHAwJDQEKOAwHCQo4DggPBDgJDxAWDA8RBDgJEQ8cDAkRAAA4DBESLAgBESYCEwQEABABEwEmAxEEAQAoEQITQT/AABIADgAJAAcACAAKABMAKBECEwA4EyAULA0UEgAoEQIUADgUHRUsDRUTLAgBEQAAAQIBLAgBFAAAAQIBLAgBFQAAAQIBLA4SESwOExQsDgkVLAgBFiYCFwQEABABFwEmAxYEAQAoFgIXQT/AAAwADgANAAwADgANABcAKBYCGAA4GCAZLA0ZFwAoFgIZADgZHRosDRoYIwIAEAAASB4iAABIDSwMEgMsDBMELAwJBSIAAEgvLAwXAywMGAQsDAsFIgAASC8sDgMRLA4EFCwOBRUjAgANAABISCIAAEhZLA4HESwOCBQsDgoVIgAASFkjAgAKAABIZiIAAEh3LA4MESwODhQsDg0VIgAASHcWDA0EBDgEBgUEOA8FBCwNEQUsDRQGBDgNCgcSOAQHCCwOBREsDgYULA4IFTECAAUsCAEEJgIFBAoAEAEFASYDBAQBACgEAgUsDAUGLA4BBgAoBgIGLA4BBgAoBgIGLA4BBgAoBgIGLA4BBgAoBgIGLA4BBgAoBgIGLA4BBgAoBgIGLA4BBgAoBgIGLA4BBgAoBgIGLA4BBiwIAQUAAAECASwOBAUmAgQECSwMIAMiAABJKgw4AwQGIwIABgAATmoiAABJPCwNBQYsDQYFACgFAgUsDgUGLAgBBQAAAQIBLA4GBSwIAQYAAAECASwOIAYsCAEHJgIIBAoAEAEIASYDBwQBACgHAggsDAgJLA4BCQAoCQIJLA4BCQAoCQIJLA4BCQAoCQIJLA4BCQAoCQIJLA4BCQAoCQIJLA4BCQAoCQIJLA4BCQAoCQIJLA4BCQAoCQIJLA4BCSYCCACCJgIKBCEsCAAhLAwFIiwMBiMsDAgkLAwHJQAQAAoAJAAAQsUsBAAALAwiCSwNCQUAKAUCBSwOBQksCAEFJgIGBAwAEAEGASYDBQQBACgFAgYmAgcECwA4BwYHLAwGCAw4CAcKFgwKCiMCAAoAAEpRLA4BCAAoCAIIIgAASjIsCAEGAAABAgEsDgUGJgIFAgkmAgcCASYCCAIALAgBCiYCCwQGABABCwEmAwoEAQAoCgILLAwLDCwOCAwAKAwCDCwOBwwAKAwCDCwOCAwAKAwCDCwOCAwAKAwCDCwOBQwsCAEFAAABAgEsDgEFLAgBBwAAAQIBLQqARgAHJwIACAABACYCCwQFLAwgAyIAAEriDDgDCwwjAgAMAABN9yIAAEr0LA0FBywIAQUmAggEDAAQAQgBJgMFBAEAKAUCCCwMCAosDgcKACgKAgosDgEKACgKAgosDgEKACgKAgosDgEKACgKAgosDgEKACgKAgosDgEKACgKAgosDgEKACgKAgosDgEKACgKAgosDgEKACgKAgosDgEKACgKAgosDgEKLA4FBiwIAQUAAAECASwOHQUsDCADIgAAS4wMOAMEByMCAAcAAE1kIgAAS54sDQUHADgHBAgOOAcICSMCAAkAAEu5JAAAQrMsDggFLA0GBCYCBwQLDDgIBwkjAgAJAABL2CQAAEE8LQQABIADJwCABAQADCQAAFDdLQiABQAFACgFAgcAOAcICSwOAgksDgUGLAgBAiYCBAQMABABBAEmAwIEAQAoAgIEJgIGBAsAOAYEBiwMBAcMOAcGCBYMCAgjAgAIAABMRywOAQcAKAcCByIAAEwoLAgBAQAAAQIBLA4CASYCAgQLLAwgAyIAAExiDDgDAgQjAgAEAABM7CIAAEx0LA0BAyYCBQQLBigFAgEmAgcEAwA4BQcGLAgBBAAQAQYBJgMEBAEAKAQCBiwOBQYAKAYCBiwOBQYmAgcEAwA4BAcGACgDAgctBAAHgAMtBAAGgAQtBAAFgAUkAABQlwAoBAIGLA0GBSYCBwQCADgGBwM2DQADAAUlJgIGBAsMOAMGByMCAAcAAE0DJAAAQTwAKAUCBgA4BgMHLA0HBCwNAQYmAggECww4AwgJIwIACQAATSwkAABBPC0EAAaAAycAgAQEAAwkAABQ3S0IgAUABwAoBwIIADgIAwksDgQJLA4HAQA4Ax0ELAwEAyIAAExiLA0GBywNBQgAOAgDCg44CAoLIwIACwAATYMkAABCsyYCCwQJDDgDCwwjAgAMAABNmiQAAEE8ACgJAgsAOAsDDCwNDAgmAgwECww4CgwNIwIADQAATb8kAABBPC0EAAeAAycAgAQEAAwkAABQ3S0IgAUACwAoCwIMADgMCg0sDggNLA4LBgA4Ax0HLAwHAyIAAEuMAjgLAwwCOAwdDQ44HQwOIwIADgAAThMkAABSyCwNBQwmAg8EBQw4DQ8QIwIAEAAATi4kAABBPAAoCgIPADgPDRAsDRAOHAwODQAsDQcOBDgNDg8AOAwPDSwODQUEOA4IDCwODAcAOAMdDCwMDAMiAABK4iwNBQYcDAMHAAA4HgcILgwACAAHJgIJBAkMOAMJCiMCAAoAAE6VJAAAQTwtBAAGgAMnAIAEBAAKJAAAUN0tCIAFAAgAKAgCCQA4CQMKLA4HCiwOCAUAOAMdBiwMBgMiAABJKiwNHwQcDCIFAAA4AwUGLgwABgAFJgIHBAMMOCIHCCMCAAgAAE74JAAAQTwtBAAEgAMnAIAEBAAEJAAAUN0tCIAFAAYAKAYCBwA4ByIILA4FCCwOBh8AOCIdBCwMBCIiAABFNSQAACIhLA0BAywNAgQmAgYEAww4BAYHIwIABwAAT1QkAABBPAAoAwIGADgGBAcsDQcFLAgBBiYCBwQCABABBwEmAwYEAQAoBgIHLAwHCCwOBQgmAgUEAQA4BAUHDjgEBwgjAgAIAABPniQAAEKzLA4DASwOBwIsDAYBJSQAACIhJgIGBAcsCAAHLAwBCCwMAgkAEAAGACQAAE8wLAQAACwMCAUmAgEABAo4AwECJgIBBAAAKAUCBwA4BwEILA0IBiMCAAIAAFBBIgAAT/0mAgEAEQo4AwECIwIAAgAAUDgiAABQFCYCAQCCCjgDAQIjAgACAABQLyYCBQQAOwkBBSwMBgQiAABQSiwMBgQiAABQSiwMBgQiAABQSiwMBAElKQEAAQXsUBlY2e4BODsBAQIlKQEAAQVjmNPyHedZZDsBAQIlKQEAAQWDDaMxQLGBIDsBAQIlKQEAAQWFTBW5j56wKTsBAQIlAQCAA4AFgActAIADgAgtAIAEgAkLAIAIgAeACiMAgAoAAFDcLQGACIAGLQKABoAJAQCACAACgAgBAIAJAAKACSIAAFCrJS0BgAOABgsAgAYAAoAHIwCABwAAUPgiAABRAy0AgAOABSIAAFFqLQAAAYAFAQAAAYAEAAEBAIADgASACS0AgAOACi0AgAWACwsAgAqACYAMIwCADAAAUVYtAYAKgAgtAoAIgAsBAIAKAAKACgEAgAsAAoALIgAAUSUnAYAFBAABAwCABgACgAYiAABRaiUkAAAiISYCBgQBJgIHBAAsDAcFIgAAUYMNKAAFgEMAByMCAAcAAFHzIgAAUZgsDQEFLA0CBiwNAwcsDQQIJgIJBAQsCAEKJgILBAUAEAELASYDCgQBACgGAgsmAgwEBAAoCgINPg8ACwANLA0KBgAoBgIGLA4GCiwOBQEsDgoCLA4HAywOCAQlLA0DBww4BQcIADgFBgcjAgAIAABSDiIAAFK/LA0BCCwNAgksDQMKLA0ECyYCDQQEDDgFDQ4jAgAOAABSNSQAAEE8ACgJAg0AOA0FDiwNDgwmAg4EAww4BQ4PIwIADwAAUlokAABBPAAoCAIOADgOBQ8sDQ8NADgMDQ4mAg0EBAw4BQ0PIwIADwAAUoQkAABBPC0EAAmAAycAgAQEAAUkAABQ3S0IgAUADAAoDAINADgNBQ8sDg4PLA4IASwODAIsDgoDLA4LBCIAAFK/LAwHBSIAAFGDKQEAAQUohpKwR9z9QzsBAQIlKQEAAQUfCi0n3IKHojsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlJAAAIiEsDQEDLA0CBCYCBgQCDDgEBgcjAgAHAABTIiQAAEE8ACgDAgYAOAYEBywNBwUsCAEGJgIHBAIAEAEHASYDBgQBACgGAgcsDAcILA4FCCYCBQQBADgEBQcOOAQHCCMCAAgAAFNsJAAAQrMsDgMBLA4HAiwMBgElJAAAIiEsCAEEJgIFBAMAEAEFASYDBAQBACgEAgUsDAUGLA4BBgAoBgIGLA4CBioCAAEAAAAAAAAAAAIAAAAAAAAAACYCCAQJLAgACSwMAQoAEAAIACQAADfOLAQAACwMCgIsDAsFLAwMBiwMDQcsDQIBACgBAgEsDgECLAgBAQAAAQIBLA4CASwNBQIAKAICAiwOAgUsCAECAAABAgEsDgUCLAgBBQAAAQIBLA4GBSwIAQYAAAECASwOBwYmAgcEACYCCAQBJgIJBAIsDAcDIgAAVE0MOAMJByMCAAcAAFSPIgAAVF8mAgQEBywIAAcsDAEILAwCCSwMBQosDAYLABAABAAkAAA4dSwEAAAsDAgDLAwDASUjAgAHAABUnCIAAFTxJgIKBAIMOAMKCyMCAAsAAFSzJAAAQTwAKAQCCgA4CgMLLA0LByYCCgQLLAgACywMAQwsDAINLAwFDiwMBg8sDAcQABAACgAkAABBYCwEAAAiAABU8QA4AwgHLAwHAyIAAFRNKQEAAQUC3G4ngHYSnTsBAQIlJAAAIiEsDQEDLA0CBCYCBgQEDDgEBgcjAgAHAABVNSQAAEE8ACgDAgYAOAYEBywNBwUsCAEGJgIHBAIAEAEHASYDBgQBACgGAgcsDAcILA4FCCYCBQQBADgEBQcOOAQHCCMCAAgAAFV/JAAAQrMsDgMBLA4HAiwMBgElKQEAAQVMtEacEMr37zsBAQIlKQEAAQWSOQpZPWHthDsBAQIlLQAYyhjK",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "NFTNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "token_id",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "NFT"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "private_nfts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "nft_exists",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_owners",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "from",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "to",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "token_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::NFTTransfer"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_to_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_to_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::prepare_private_balance_increase_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::prepare_private_balance_increase_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "slot",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "point",
                    "type": {
                      "fields": [
                        {
                          "name": "x",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "y",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "is_infinite",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                    }
                  },
                  {
                    "name": "setup_log",
                    "type": {
                      "kind": "array",
                      "length": 9,
                      "type": {
                        "kind": "field"
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_store_payload_in_transient_storage_unsafe_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_store_payload_in_transient_storage_unsafe_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_in_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_in_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "inner_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::cancel_authwit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::cancel_authwit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_finish_transfer_to_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_finish_transfer_to_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hiding_point_slot",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::_finalize_transfer_to_private_unsafe_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::_finalize_transfer_to_private_unsafe_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hiding_point_slot",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::finalize_transfer_to_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::finalize_transfer_to_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::private_get_symbol_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::private_get_symbol_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::public_get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::public_get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_to_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_to_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::private_get_name_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::private_get_name_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::set_admin_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::set_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::public_get_symbol_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "compressed_string::field_compressed_string::FieldCompressedString"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::public_get_symbol_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "NFT::get_admin_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::get_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::transfer_in_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::transfer_in_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::mint_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::mint_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "NFT::owner_of_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "NFT::owner_of_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/partial_note.nr",
      "source": "// THIS FILE WILL GO AWAY WHEN WE REFACTOR PARTIAL NOTES, SO I DON'T FEEL TOO\n// GUILTY ABOUT THE OBVIOUS CODE DUPLICATION VS note.nr & event.nr.\n\nuse crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::note::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    utils::{bytes::{be_bytes_31_to_fields, get_random_bytes}, point::get_sign_of_point},\n};\nuse dep::protocol_types::{address::{aztec_address::ToField, AztecAddress}, hash::poseidon2_hash};\nuse std::aes128::aes128_encrypt;\n\npub fn compute_partial_public_log_payload<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    plaintext: [u8; N],\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; M] {\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient); // not to be confused with the tagging shared secret\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Prepend/append extra bytes\n    // *****************************************************************************\n\n    // \"Proper\" meaning the main meaty stuff that we care about.\n    let proper_plaintext: [u8; N] = plaintext;\n    let final_plaintext = proper_plaintext;\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(final_plaintext, iv, sym_key);\n\n    assert(ciphertext_bytes.len() == 16 * (1 + (2 + N) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = contract_address_bytes.len();\n\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 = get_arr_of_size__log_bytes_padding__from_PT::<2 + N>();\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<2 + N>();\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    let log_bytes_as_fields = be_bytes_31_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // We don't add any extra random padding.\n    // Whilst we do this in note.nr, we won't do it for this partial_note log, because it's going to get stored in public, and so:\n    // - The nature of the tx is going to be leaked.\n    // - We therefore don't care if it's padded to obscure the length of the actual ciphertext.\n    // Note: partial logs are going to be greatly refactored, soon.\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    // TODO(#10273) This should be done by the AVM when it's processing the raw logs instead of their hashes.\n    let siloed_tag = poseidon2_hash([contract_address.to_field(), tag]);\n\n    // Temporary hack so that the partial public log remains the same format.\n    // It should return field array and make the tag the first field as compute_private_log_payload does.\n\n    let mut final_log: [Field; M] = [0; M];\n\n    final_log[0] = siloed_tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n\n    final_log\n}\n"
    },
    "105": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "112": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        /// Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "114": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::embedded_curve_ops::multi_scalar_mul;\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "115": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::{\n    embedded_curve_ops::fixed_base_scalar_mul, field::bn254::decompose,\n    hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "116": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    /// Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "122": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "131": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/discovery/mod.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    context::unconstrained_context::UnconstrainedContext, note::note_header::NoteHeader,\n    oracle::note_discovery::deliver_note, utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::compute_note_hash_nonce,\n};\n\n// We reserve two fields in the note log that are not part of the note content: one for the storage slot, and one for\n// the note type id.\nglobal NOTE_LOG_RESERVED_FIELDS: u32 = 2;\npub global MAX_NOTE_SERIALIZED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashesAndNullifier {\n    pub note_hash: Field,\n    pub unique_note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Processes a log given its plaintext by trying to find notes encoded in it. This process involves the discovery of\n/// the nonce of any such notes, which requires knowledge of the transaction hash in which the notes would've been\n/// created, along with the list of unique note hashes in said transaction.\n///\n/// Additionally, this requires a `compute_note_hash_and_nullifier` lambda that is able to compute these values for any\n/// note in the contract given their contents. A typical implementation of such a function would look like this:\n///\n/// ```\n/// |packed_note_content, note_header, note_type_id| {\n///     let hashes = if note_type_id == MyNoteType::get_note_type_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///         dep::aztec::note::utils::compute_note_hash_and_optionally_a_nullifier(\n///             MyNoteType::unpack_content,\n///             note_header,\n///             true,\n///             storage_slot,\n///             packed_note_content.storage(),\n///         )\n///     } else {\n///         panic(f\"Unknown note type id {note_type_id}\")\n///     };\n///\n///     Option::some(dep::aztec::oracle::management::NoteHashesAndNullifier {\n///         note_hash: hashes[0],\n///         unique_note_hash: hashes[1],\n///         inner_nullifier: hashes[3],\n///     })\n/// }\n/// ```\npub unconstrained fn do_process_log<Env>(\n    context: UnconstrainedContext,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: fn[Env](BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>, NoteHeader, Field, Field) -> Option<NoteHashesAndNullifier>,\n) {\n    let (storage_slot, note_type_id, packed_note_content) =\n        destructure_log_plaintext(log_plaintext);\n\n    // We need to find the note's nonce, which is the one that results in one of the unique note hashes from tx_hash\n    for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            let header = NoteHeader::new(context.this_address(), candidate_nonce);\n\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                header,\n                storage_slot,\n                note_type_id,\n            )\n                .unwrap();\n\n            if hashes.unique_note_hash == expected_unique_note_hash {\n                // TODO(#10726): push these into a vec to deliver all at once instead of having one oracle call per note\n\n                assert(\n                    deliver_note(\n                        context.this_address(), // TODO(#10727): allow other contracts to deliver notes\n                        storage_slot,\n                        candidate_nonce,\n                        packed_note_content,\n                        hashes.note_hash,\n                        hashes.inner_nullifier,\n                        tx_hash,\n                        recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_LOG_RESERVED_FIELDS == 2,\n        \"unepxected value for NOTE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n    let note_type_id = log_plaintext.get(1);\n\n    let packed_note_content = array::subbvec(log_plaintext, NOTE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, packed_note_content)\n}\n\nfn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..MaxLen {\n        if i < vec.len() {\n            f(vec.get_unchecked(i), i);\n        }\n    }\n}\n"
    },
    "132": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note_content = Note::pack_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        packed_note_content,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note, storage_slot)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note, storage_slot: Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note, storage_slot);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "134": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field) -> Self {\n        Self { note, storage_slot }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "136": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note_content: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note_content[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n}\n\nfn check_note_content<let N: u32>(\n    packed_note_content: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note_content, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    /// Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    /// is check that the metadata is correct, and that the note exists.\n    let note = unsafe { get_note_internal(storage_slot) };\n    check_note_header(*context, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    /// Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.pack_content();\n            check_note_header(*context, note);\n            check_note_content(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "141": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr",
      "source": "use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteInterface;\nuse dep::protocol_types::traits::ToField;\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteInterface<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n"
    },
    "142": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header, storage_slot);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash(storage_slot);\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note, storage_slot: Field) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note, storage_slot);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    unpack_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    storage_slot: Field,\n    packed_note_content: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = unpack_content(array::subarray(packed_note_content, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash(storage_slot);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context(storage_slot)\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "145": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "147": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "148": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "149": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "150": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    /// Safety: The to_address function combines all values in the instance object to produce an address,\n    /// so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "154": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "155": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "156": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "159": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::note::discovery::MAX_NOTE_SERIALIZED_LEN;\nuse dep::protocol_types::address::AztecAddress;\n\n/// Informs PXE of a note's existence so that it can later retrieved by the `getNotes` oracle. The note will be scoped\n/// to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The note's `content` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value is\n/// typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are the\n/// inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree at\n/// `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was sucessfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        content,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n"
    },
    "160": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note_content,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note_content: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::unpack_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "161": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "162": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "164": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "169": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // TODO: This function is still around because of a stale blacklist token. It should most likely be nuked. If you\n    // need this functionality use partial notes instead.\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "171": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: U128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "172": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "191": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    /// Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "193": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "194": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    vec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(vec.storage(), offset), vec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "195": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/bytes.nr",
      "source": "use crate::oracle::random::random;\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole bytes.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted into a Field. If the last chunk\n/// is less than 31 bytes long, then only the relevant bytes are considered.\n/// For example, [1, 10, 3] is encoded as [1 * 256^2 + 10 * 256 + 3]\n/// Note: ceil(N / 31) = (N + 30) / 31\npub fn be_bytes_31_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = [0; (N + 30) / 31];\n\n    // There are N / 31 whole fields that can be populated.\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    // Note: if 31 divides N, then this loop does not execute.\n    // ceil(N/31) - floor(N/31) = 1, unless 31 divides N, in which case it's 0.\n    for _ in 0..((N + 30) / 31) - (N / 31) {\n        let mut final_field = 0;\n        let final_field_idx = fields.len() - 1;\n        let final_offset = final_field_idx * 31;\n        // N - ((N / 31) * 31) = N - floor(N/31) * 31 = the number of bytes to go in the final field.\n        for j in 0..N - ((N / 31) * 31) {\n            // Shift the existing value left by 8 bits and add the new byte\n            final_field = final_field * 256 + bytes[final_offset + j] as Field;\n        }\n\n        fields[final_field_idx] = final_field;\n    }\n\n    fields\n}\n\npub fn le_bytes_31_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = [0; (N + 30) / 31];\n\n    // There are N / 31 whole fields that can be populated.\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            let k = 31 - j - 1; // iterate in reverse.\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + k] as Field;\n        }\n        fields[i] = field;\n    }\n\n    // Note: if 31 divides N, then this loop does not execute.\n    // ceil(N/31) - floor(N/31) = 1, unless 31 divides N, in which case it's 0.\n    for _ in 0..((N + 30) / 31) - (N / 31) {\n        let mut final_field = 0;\n        let final_field_idx = fields.len() - 1;\n        let final_offset = final_field_idx * 31;\n        // N - ((N / 31) * 31) = N - floor(N/31) * 31 = the number of bytes to go in the final field.\n        for j in 0..N - ((N / 31) * 31) {\n            let k = (N - ((N / 31) * 31)) - j - 1; // iterate in reverse.\n            // Shift the existing value left by 8 bits and add the new byte\n            final_field = final_field * 256 + bytes[final_offset + k] as Field;\n        }\n        fields[final_field_idx] = final_field;\n    }\n\n    fields\n}\n\n/// Converts an input array of fields into a single array of bytes.\n/// Each input field must contain only 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte\n/// chunks are concatenated back together in the order of the original fields.\n///\n/// It appears that the original author of this function wants to give the caller some control\n/// over the number of bytes that are returned: the final field can be mapped to fewer than 31 bytes,\n/// based on the caller's choice of M.\n/// Given the input is N fields, and each field (except the last) is mapped to 31 bytes,\n/// we definitely need M > (N - 1) * 31 to cover those first (N - 1) fields. Hence the static assertion.\n/// TODO: this is the same as the \"le\" version of this function, save for the `field.to_be_bytes()` calls. I tried passing the conversion function in as a parameter, to reduce code duplication, but couldn't get it to work.\npub fn fields_to_be_bytes_31<let N: u32, let M: u32>(fields: [Field; N]) -> [u8; M] {\n    let mut bytes = [0; M];\n\n    std::static_assert(M > (N - 1) * 31, \"Not enough output bytes specified\");\n    // We make this assertion to keep the logic simpler:\n    std::static_assert(N * 31 >= M, \"Too many output bytes specified.\");\n\n    for i in 0..N - 1 {\n        let field = fields[i];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes[i * 31 + j] = field_as_bytes[j];\n        }\n    }\n\n    let final_field = fields[N - 1];\n    final_field.assert_max_bit_size::<8 * (M - ((N - 1) * 31))>();\n\n    let final_field_as_bytes: [u8; M - ((N - 1) * 31)] = final_field.to_be_bytes();\n\n    let start_index = (N - 1) * 31;\n    for j in 0..M - ((N - 1) * 31) {\n        bytes[start_index + j] = final_field_as_bytes[j];\n    }\n\n    bytes\n}\n\n/// Converts an input array of fields into a single array of bytes.\n/// Each input field must contain only 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 little-endian bytes, and the resulting 31-byte\n/// chunks are concatenated back together in the order of the original fields. You'll\n/// end up with quite a strange ordering of bytes if you use this particular function.\npub fn fields_to_le_bytes_31<let N: u32, let M: u32>(fields: [Field; N]) -> [u8; M] {\n    let mut bytes = [0; M];\n\n    std::static_assert(M > (N - 1) * 31, \"Not enough output bytes specified\");\n    // We make this assertion to keep the logic simpler:\n    std::static_assert(N * 31 >= M, \"Too many output bytes specified.\");\n\n    for i in 0..N - 1 {\n        let field = fields[i];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_le_bytes();\n\n        for j in 0..31 {\n            bytes[i * 31 + j] = field_as_bytes[j];\n        }\n    }\n\n    let final_field = fields[N - 1];\n    final_field.assert_max_bit_size::<8 * (M - ((N - 1) * 31))>();\n\n    let final_field_as_bytes: [u8; M - ((N - 1) * 31)] = final_field.to_le_bytes();\n\n    let start_index = (N - 1) * 31;\n    for j in 0..M - ((N - 1) * 31) {\n        bytes[start_index + j] = final_field_as_bytes[j];\n    }\n\n    bytes\n}\n\n/// Converts an input array of fields into a single array of bytes.\n/// Each field is converted to a 32-byte big-endian array.\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end,\n/// every 32 bytes. Be careful that such a gap doesn't leak information!\npub fn fields_to_be_bytes_32<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field = fields[i];\n        let field_as_bytes: [u8; 32] = field.to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\nunconstrained fn byte_to_bits(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\n/// Returns as many random bits as specified through N.\nunconstrained fn get_random_bits<let N: u32>() -> [u1; N] {\n    // Note: (N + 7) / 8 = ceil(N / 8)\n    let bytes = get_random_bytes::<(N + 7) / 8>();\n    let mut bits: [u1; N] = [0; N];\n    for i in 0..bytes.len() - 1 {\n        let mut byte = bytes[i];\n        for j in 0..8 {\n            let bit_idx = i * 8 + j;\n            bits[bit_idx] = (byte & 1) as u1;\n            byte >>= 1;\n        }\n    }\n\n    // N - ((N / 8) * 8) = N - floor(N/8) * 8 = the number of bits remaining.\n    let byte_idx = bytes.len() - 1;\n    let mut byte = bytes[byte_idx];\n    for j in 0..N - ((N / 8) * 8) {\n        let bit_idx = (byte_idx) * 8 + j;\n        bits[bit_idx] = (byte & 1) as u1;\n        byte >>= 1;\n    }\n\n    bits\n}\n\n/// Returns random bits, in chunks, according to the provided numeric generics.\nunconstrained fn get_chunks_of_random_bits<let NUM_CHUNKS: u32, let NUM_BITS: u32>() -> [[u1; NUM_BITS]; NUM_CHUNKS] {\n    let random_bits = get_random_bits::<NUM_CHUNKS * NUM_BITS>();\n    let mut chunks: [[u1; NUM_BITS]; NUM_CHUNKS] = [[0; NUM_BITS]; NUM_CHUNKS];\n    for i in 0..NUM_CHUNKS {\n        let mut chunk: [u1; NUM_BITS] = [0; NUM_BITS];\n        for j in 0..NUM_BITS {\n            chunk[j] = random_bits[i * NUM_BITS + j];\n        }\n        chunks[i] = chunk;\n    }\n    chunks\n}\n\n/**\n * Helper fn for be/le_bytes_to_padded_fields() fns.\n */\nfn pad_31_byte_fields_with_random_bits<let N: u32>(input: [Field; N]) -> [Field; N] {\n    /// Safety: we can't constrain whether or not the returned bits are actually random;\n    /// we can only rely on it being in the caller's best interest.\n    let chunks_of_random_bits = unsafe { get_chunks_of_random_bits::<((N + 30) / 31), 6>() };\n    let mut fields = input;\n    // We push the random bits to the \"big end\" of each field\n    let TWO_POW_248 = 0x100000000000000000000000000000000000000000000000000000000000000;\n    for i in 0..fields.len() {\n        let mut shift = TWO_POW_248;\n        for j in 0..5 {\n            fields[i] += shift * chunks_of_random_bits[i][j] as Field;\n            shift *= 2;\n        }\n\n        // This might overflow the field modulus, so we need to be careful.\n        // By this point, shift = 2 ^ 253, so will populate the 254th bit (counting from 1)\n        let field_with_254th_bit = fields[i] + shift * chunks_of_random_bits[i][6 - 1] as Field;\n\n        // Expensive comparison (one for each field), but it's important -- if we want to hide that we were\n        // working with bytes -- that we include the 254th random bit when it fits.\n        fields[i] = if (fields[i].lt(field_with_254th_bit)) {\n            field_with_254th_bit\n        } else {\n            fields[i]\n        };\n    }\n    fields\n}\n\n/**\n * The above functions be_bytes_31_to_fields and le_bytes_31_to_fields have a privacy-leakage problem:\n * they result in fields which are all 248-bits instead of 254-bits.\n * That means if the above functions are used to convert a ciphertext from bytes to\n * fields, it leaks (with very high probability) to all observers of the log that the\n * ciphertext was created with a \"bit twiddly\" encryption scheme like AES.\n * This reduces privacy sets for all apps.\n *\n * This function seeks to \"pad\" those remaining 6 bits with randomness, so that all\n * encrypted logs look even more similar (full fields of 254-bits of random-looking\n * information). Of course, this adds some extra constraints, unfortunately.\n */\npub fn le_bytes_to_padded_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = le_bytes_31_to_fields(input);\n    pad_31_byte_fields_with_random_bits(fields)\n}\n\npub fn be_bytes_to_padded_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut fields = be_bytes_31_to_fields(input);\n    pad_31_byte_fields_with_random_bits(fields)\n}\n\nmod test {\n    use crate::utils::bytes::{\n        be_bytes_31_to_fields, fields_to_be_bytes_31, fields_to_le_bytes_31, le_bytes_31_to_fields,\n    };\n\n    // BE BYTES\n\n    #[test]\n    fn test_be_bytes_31_to_1_field() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31,\n        ];\n        let output = be_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_be_bytes_31() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_be_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_be_bytes_31() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_be_bytes_31(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_fewer_be_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_be_bytes_31(input);\n        println(f\"output: {output}\");\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_be_bytes_31_to_2_fields() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        ];\n        let output = be_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n        assert_eq(output[1], 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n    }\n\n    #[test]\n    fn test_2_fields_to_be_bytes_31() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_be_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\n                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_be_bytes_31_input_to_fields_and_back(input: [u8; 128]) {\n        let output = be_bytes_31_to_fields(input);\n        let input_back: [u8; 128] = fields_to_be_bytes_31(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_be_bytes_31_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_be_bytes_31(input);\n        let input_back = be_bytes_31_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_too_few_destination_be_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_be_bytes_31(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_be_bytes_31_value_too_large() {\n        let input = [2.pow_32(248)]; // this number is 1 bit larger than 31 bytes.\n        let _ignored_result: [u8; 31] = fields_to_be_bytes_31(input);\n    }\n\n    #[test]\n    fn test_fields_to_be_bytes_31_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_be_bytes_31(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n\n    // LE BYTES\n\n    #[test]\n    fn test_le_bytes_31_to_1_field() {\n        let input = [\n            31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10,\n            9, 8, 7, 6, 5, 4, 3, 2, 1,\n        ];\n        let output = le_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_le_bytes_31() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_le_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,\n                10, 9, 8, 7, 6, 5, 4, 3, 2, 1,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_le_bytes_31() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_le_bytes_31(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 0,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_fewer_le_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_le_bytes_31(input);\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_le_bytes_31_to_2_fields() {\n        let input = [\n            59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38,\n            37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,\n            15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1,\n        ];\n        let output = le_bytes_31_to_fields(input);\n\n        assert_eq(output[0], 0x1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n        assert_eq(output[1], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c);\n    }\n\n    #[test]\n    fn test_2_fields_to_le_bytes_31() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_le_bytes_31(input);\n\n        assert_eq(\n            output,\n            [\n                31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,\n                10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47,\n                46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 0, 0, 0,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_le_bytes_input_to_fields_and_back(input: [u8; 128]) {\n        let output = le_bytes_31_to_fields(input);\n        let input_back: [u8; 128] = fields_to_le_bytes_31(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_le_bytes_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_le_bytes_31(input);\n        let input_back = le_bytes_31_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_too_few_destination_le_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_le_bytes_31(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_le_bytes_31_value_too_large() {\n        let input = [2.pow_32(248)];\n        let _ignored_result: [u8; 31] = fields_to_le_bytes_31(input);\n    }\n\n    #[test]\n    fn test_fields_to_le_bytes_31_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_le_bytes_31(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n}\n"
    },
    "196": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "199": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
    },
    "202": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            /// Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "219": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "255": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "262": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "27": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// docs:start:sha256\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\n#[deprecated(\"sha256 is being deprecated from the stdlib, use https://github.com/noir-lang/sha256 instead\")]\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    /// Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        /// Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        /// Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        /// Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "277": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "278": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "279": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "280": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "289": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "295": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "296": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        /// Safety: `sorted` array is checked to be:\n        /// a. a permutation of `input`'s elements\n        /// b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"
    },
    "305": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "308": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "321": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "325": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::{Packable, ToField};\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for U128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self.to_field()]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "326": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 2;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        // We use little-endian ordering to match the order in which U128 defines its limbs.\n        // This is necessary because of how Noir handles serialization:\n        // - When calling a contract function from TypeScript, the serialization in encoder.ts gets used and then Noir\n        //   deserializes using its intrinsic serialization logic (based on the limb order in the struct).\n        // - When calling a contract function from another function, the `serialize` method is invoked on the type\n        //   first.\n        // For this reason if we didn't use the ordering of U128 limbs here and in encoder.ts we would get an arguments\n        // hash mismatch.\n        // The below warning is due to visibility in noir stdlib.\n        [self.lo, self.hi]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_u64s_le(fields[0] as u64, fields[1] as u64)\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "342": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    /// Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    /// of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    /// Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "343": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "345": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "350": {
      "path": "/Users/hka/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "359": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/compressed-string/src/field_compressed_string.nr",
      "source": "use dep::aztec::protocol_types::{\n    traits::{Deserialize, Packable, Serialize},\n    utils::field::field_from_bytes,\n};\nuse std::meta::derive;\n\n// A Fixedsize Compressed String.\n// Essentially a special version of Compressed String for practical use.\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct FieldCompressedString {\n    value: Field,\n}\n\nimpl FieldCompressedString {\n    pub fn is_eq(self, other: FieldCompressedString) -> bool {\n        self.value == other.value\n    }\n\n    pub fn from_field(input_field: Field) -> Self {\n        Self { value: input_field }\n    }\n\n    pub fn from_string(input_string: str<31>) -> Self {\n        Self { value: field_from_bytes(input_string.as_bytes(), true) }\n    }\n\n    pub fn to_bytes(self) -> [u8; 31] {\n        self.value.to_be_bytes()\n    }\n}\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "62": {
      "path": "/Users/hka/tezac/src/contracts/erc721/src/main.nr",
      "source": "mod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract NFT {\n    use crate::types::nft_note::NFTNote;\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    use dep::aztec::{\n        encrypted_logs::log_assembly_strategies::default_aes128::note::encode_and_encrypt_note,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        note::constants::MAX_NOTES_PER_PAGE,\n        oracle::random::random,\n        prelude::{\n            AztecAddress, Map, NoteGetterOptions, NoteViewerOptions, PrivateContext, PrivateSet,\n            PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n        utils::comparison::Comparator,\n    };\n    use dep::compressed_string::FieldCompressedString;\n    use std::meta::derive;\n\n    #[derive(Serialize)]\n    #[event]\n    pub struct NFTTransfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        token_id: Field,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        name: PublicImmutable<FieldCompressedString, Context>,\n        admin: PublicMutable<AztecAddress, Context>,\n        private_nfts: Map<AztecAddress, PrivateSet<NFTNote, Context>, Context>,\n        nft_exists: Map<Field, PublicMutable<bool, Context>, Context>,\n        public_owners: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not an admin\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    fn mint(to: AztecAddress, token_id: Field) {\n        assert(token_id != 0, \"zero token ID not supported\");\n        assert(storage.nft_exists.at(token_id).read() == false, \"token already exists\");\n\n        storage.nft_exists.at(token_id).write(true);\n\n        storage.public_owners.at(token_id).write(to);\n    }\n\n    #[public]\n    #[view]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let public_owners_storage = storage.public_owners.at(token_id);\n        assert(public_owners_storage.read().eq(from), \"invalid owner\");\n\n        public_owners_storage.write(to);\n    }\n\n    #[private]\n    fn transfer_to_private(to: AztecAddress, token_id: Field) {\n        let from = context.msg_sender();\n\n        let nft = NFT::at(context.this_address());\n\n        // We prepare the private balance increase.\n        let hiding_point_slot = _prepare_private_balance_increase(to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own NFTs.\n        nft._finalize_transfer_to_private_unsafe(from, token_id, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// `finalize_transfer_to_private. Returns a hiding point slot.\n    // docs:start:prepare_private_balance_increase\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress) -> Field {\n        _prepare_private_balance_increase(to, &mut context, storage)\n    }\n    \n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.private_nfts.at(to).storage_slot;\n\n        // We create a setup payload with unpopulated/zero token id for 'to'\n\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = NFTNote::setup_payload().new(to, note_randomness, to_note_slot);\n\n        let setup_log = note_setup_payload.encrypt_log(context, to, context.msg_sender());\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_to_private`.\n\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        NFT::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    // docs:start:store_payload_in_transient_storage_unsafe\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 9],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    /// Finalizes a transfer of NFT with `token_id` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    // docs:start:finalize_transfer_to_private\n    #[public]\n    fn finalize_transfer_to_private(token_id: Field, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, token_id, hiding_point_slot, &mut context, storage);\n    }\n\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        token_id: Field,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_to_private(from, token_id, hiding_point_slot, &mut context, storage);\n    }\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        token_id: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let public_owners_storage = storage.public_owners.at(token_id);\n        assert(public_owners_storage.read().eq(from), \"invalid NFT owner\");\n\n        // Set the public NFT owner to zero\n        public_owners_storage.write(AztecAddress::zero());\n\n        // Finalize the partial note with the `token_id`\n        let finalization_payload =\n            NFTNote::finalization_payload().new(context, hiding_point_slot, token_id);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    //\n    // Cancel a private authentication witness.\n    // @param inner_hash The inner hash of the authwit to cancel.\n    //\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let nfts = storage.private_nfts;\n\n        let notes = nfts.at(from).pop_notes(NoteGetterOptions::new()\n            .select(NFTNote::properties().token_id, Comparator.EQ, token_id)\n            .set_limit(1));\n        assert(notes.len() == 1, \"NFT not found when transferring\");\n\n        let mut new_note = NFTNote::new(token_id, to);\n\n        nfts.at(to).insert(&mut new_note).emit(encode_and_encrypt_note(&mut context, to, from));\n    }\n\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, token_id: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let notes = storage.private_nfts.at(from).pop_notes(NoteGetterOptions::new()\n            .select(NFTNote::properties().token_id, Comparator.EQ, token_id)\n            .set_limit(1));\n        assert(notes.len() == 1, \"NFT not found when transferring to public\");\n\n        NFT::at(context.this_address())._finish_transfer_to_public(to, token_id).enqueue(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _finish_transfer_to_public(to: AztecAddress, token_id: Field) {\n        storage.public_owners.at(token_id).write(to);\n    }\n\n    #[public]\n    #[view]\n    // Returns zero address when the token does not have a public owner. Reverts if the token does not exist.\n    fn owner_of(token_id: Field) -> AztecAddress {\n        assert(storage.nft_exists.at(token_id).read(), \"token does not exist\");\n        storage.public_owners.at(token_id).read()\n    }\n\n    /// Returns an array of token IDs owned by `owner` in private and a flag indicating whether a page limit was\n    /// reached. Starts getting the notes from page with index `page_index`. Zero values in the array are placeholder\n    /// values for non-existing notes.\n    // docs:start:get_private_nfts\n    unconstrained fn get_private_nfts(\n        owner: AztecAddress,\n        page_index: u32,\n    ) -> pub ([Field; MAX_NOTES_PER_PAGE], bool) {\n        let offset = page_index * MAX_NOTES_PER_PAGE;\n        let mut options = NoteViewerOptions::new();\n        let notes = storage.private_nfts.at(owner).view_notes(options.set_offset(offset));\n\n        let mut owned_nft_ids = [0; MAX_NOTES_PER_PAGE];\n        for i in 0..options.limit {\n            if i < notes.len() {\n                owned_nft_ids[i] = notes.get_unchecked(i).token_id;\n            }\n        }\n\n        let page_limit_reached = notes.len() == options.limit;\n        (owned_nft_ids, page_limit_reached)\n    }\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/Users/hka/tezac/src/contracts/erc721/src/types/nft_note.nr",
      "source": "use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Packable,\n    },\n};\n\n// docs:start:nft_note\n#[partial_note(quote {token_id})]\npub struct NFTNote {\n    // ID of the token\n    token_id: Field,\n    // The owner of the note\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:nft_note\n\nimpl NullifiableNote for NFTNote {\n    // docs:start:compute_nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:compute_nullifier\n\n    unconstrained fn compute_nullifier_without_context(self, storage_slot: Field) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self, storage_slot);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl NFTNote {\n    pub fn new(token_id: Field, owner: AztecAddress) -> Self {\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        NFTNote { token_id, owner, randomness, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for NFTNote {\n    fn eq(self, other: Self) -> bool {\n        (self.token_id == other.token_id)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}"
    },
    "74": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "83": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "90": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            /// for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\n        /// to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "91": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, Packable, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "92": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        /// Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "93": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "95": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use std::hash::{from_field_unsafe as fr_to_fq_unsafe, sha256};\n\nuse dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "99": {
      "path": "/Users/hka/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.76.4/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::{be_bytes_31_to_fields, get_random_bytes}, point::get_sign_of_point},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\nuse std::aes128::aes128_encrypt;\n\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48; // contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\n\n/*\n * WHY IS THERE LOTS OF CODE DUPLICATION BETWEEN event.nr and note.nr?\n * It's because there are a few more optimisations that can be done for notes,\n * and so the stuff that looks like duplicated code currently, won't be\n * the same for long.\n * To modularise now feels premature, because we might get that modularisation wrong.\n * Much better (imo) to have a flattened templates for log assembly, because it\n * makes it much easier for us all to follow, it serves as a nice example for the\n * community to follow (if they wish to roll their own log layouts), and it gives\n * us more time to spot common patterns across all kinds of log layouts.\n */\n\n/*\n * LOG CONFIGURATION CHOICES:\n *\n * deliver_to: INPUT as recipient: AztecAddress\n * encrypt_with: aes128 CBC (Cipher Block Chaining)\n * shared_secret: ephemeral\n * shared_secret_randomness_extraction_hash: sha256\n * tag: true\n * tag_from: INPUT as sender: AztecAddress\n *\n * Note-specific:\n * derive_note_randomness_from_shared_secret: false\n *\n */\n\n/*\n * LOG LAYOUT CHOICE:\n *\n * Short explanation:\n * log = [tag, epk, header_ct=[[contract_address, ct_len], pkcs7_pad], ct=[[pt], pkcs7_pad], some bytes padding, some fields padding]\n *\n * Long explanation:\n * tag: Field\n * epk: [Field, u8]\n * header_ct: [[u8; 32], [u8; 2], [u8; 16]]\n * ct: [[u8; 2], [u8; x], [u8; y]]\n *\n * More precisely (in pseudocode):\n *\n * log = [\n *     tag: Field,\n *     Epk: Field,\n *\n *     le_bytes_31_to_fields(\n *\n *         log_bytes: [\n *             eph_pk_sign: [u8; 1],\n *\n *             header_ciphertext: aes_encrypt(\n *                 contract_address: [u8; 32],\n *                 ct_length: [u8; 2],\n *\n *                 // the aes128_encrypt fn automatically inserts padding:\n *                 header_pt_aes_padding: [u8; 14], // `16 - (input.len() % 16)`\n\n *             ): [u8; 48],\n *\n *             ciphertext: aes_encrypt(\n *                 final_pt: [\n *                     pt: {\n *                         note_bytes: {\n *                             storage_slot: [u8; 32],\n *                             note_type_id: [u8; 32],\n *                             ...note: [u8; N * 32],\n *                         }: [u8; N * 32 + 64],\n *                     }: [u8; N * 32 + 64],\n\n *                 ]: [u8; N * 32 + 64],\n *\n *                 // the aes128_encrypt fn automatically inserts padding:\n *                 pt_aes_padding: [u8; 16 - ( (|pt_length| + |pt|) % 16 )]\n *\n *             ): [u8; |pt| + |pt_aes_padding|]\n *                [u8; |ct|]\n *\n *             log_bytes_padding_to_mult_31: [u8; 31 * ceil((1 + 48 + |ct|)/31) - (1 + 48 + |ct|)],\n *                                           [u8; p]\n *\n *         ]: [u8; 1 + 48 + |ct| + p]\n *\n *     ): [Field; (1 + 48 + |ct| + p) / 31]\n *\n *     log_fields_padding: [Field; PRIVATE_LOG_SIZE_IN_FIELDS - 2 - (1 + 48 + |ct| + p) / 31],\n *\n * ]: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\n *\n *\n */\n\n/********************************************************/\n// Disgusting arithmetic on generics\n/********************************************************/\n\n// In this section, instead of initialising arrays with very complicated generic\n// arithmetic, such as:\n// let my_arr: [u8; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))] = [0; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))];\n//... we instead do the arithmetic a little bit at a time, so that the computation\n// can be audited and understood. Now, we can't do arithmetic on generics in the body\n// of a function, so we abusing functions in the following way:\n\n// |full_pt| = |pt| = (N * 32) + 64\nfn get_arr_of_size__full_plaintext<let PT: u32>() -> [u8; PT] {\n    [0; PT]\n}\n\n// |pt_aes_padding| = 16 - (|full_pt| % 16)\nfn get_arr_of_size__plaintext_aes_padding<let FULL_PT: u32>(\n    _full_pt: [u8; FULL_PT],\n) -> [u8; 16 - (FULL_PT % 16)] {\n    [0; 16 - (FULL_PT % 16)]\n}\n\n// |ct| = |full_pt| + |pt_aes_padding|\nfn get_arr_of_size__ciphertext<let FULL_PT: u32, let PT_AES_PADDING: u32>(\n    _full_pt: [u8; FULL_PT],\n    _pt_aes_padding: [u8; PT_AES_PADDING],\n) -> [u8; FULL_PT + PT_AES_PADDING] {\n    [0; FULL_PT + PT_AES_PADDING]\n}\n\n// Ok, so we have the following bytes:\n// eph_pk_sign, header_ciphertext, ciphertext:\n// Let lbwop = 1 + 48 + |ct| // aka log bytes without padding\nfn get_arr_of_size__log_bytes_without_padding<let CT: u32>(_ct: [u8; CT]) -> [u8; 1 + 48 + CT] {\n    [0; 1 + 48 + CT]\n}\n\n// Recall:\n//   lbwop := 1 + 48 + |ct| // aka log bytes without padding\n// We now want to pad b to the next multiple of 31, so as to \"fill\" fields.\n// Let p be that padding.\n// p = 31 * ceil(lbwop / 31) - lbwop\n//   = 31 * ((lbwop + 30) // 31) - lbwop\n//     (because ceil(x / y) = (x + y - 1) // y ).\nfn get_arr_of_size__log_bytes_padding<let LBWOP: u32>(\n    _lbwop: [u8; LBWOP],\n) -> [u8; (31 * ((LBWOP + 30) / 31)) - LBWOP] {\n    [0; (31 * ((LBWOP + 30) / 31)) - LBWOP]\n}\n\n// |log_bytes| = 1 + 48 + |ct| + p // aka log bytes (with padding)\n// Recall:\n//   lbwop := 1 + 48 + |ct|\n//   p is the padding\nfn get_arr_of_size__log_bytes<let LBWOP: u32, let P: u32>(\n    _lbwop: [u8; LBWOP],\n    _p: [u8; P],\n) -> [u8; LBWOP + P] {\n    [0; LBWOP + P]\n}\n\n// The return type is pasted from the LSP's expectation, because it was too difficult\n// to match its weird way of doing algebra. It doesn't know all rules of arithmetic.\n// PT is the plaintext length.\npub(crate) fn get_arr_of_size__log_bytes_padding__from_PT<let PT: u32>() -> [u8; ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49))] {\n    let full_pt = get_arr_of_size__full_plaintext::<PT>();\n    let pt_aes_padding = get_arr_of_size__plaintext_aes_padding(full_pt);\n    let ct = get_arr_of_size__ciphertext(full_pt, pt_aes_padding);\n    let lbwop = get_arr_of_size__log_bytes_without_padding(ct);\n    let p = get_arr_of_size__log_bytes_padding(lbwop);\n    p\n}\n\n// The return type is pasted from the LSP's expectation, because it was too difficult\n// to match its weird way of doing algebra. It doesn't know all rules of arithmetic.\npub(crate) fn get_arr_of_size__log_bytes__from_PT<let PT: u32>() -> [u8; (((PT + (16 - (PT % 16))) + 49) + ((((((PT + (16 - (PT % 16))) + 49) + 30) / 31) * 31) - ((PT + (16 - (PT % 16))) + 49)))] {\n    let full_pt = get_arr_of_size__full_plaintext::<PT>();\n    let pt_aes_padding = get_arr_of_size__plaintext_aes_padding(full_pt);\n    let ct = get_arr_of_size__ciphertext(full_pt, pt_aes_padding);\n    let lbwop = get_arr_of_size__log_bytes_without_padding(ct);\n    let p = get_arr_of_size__log_bytes_padding(lbwop);\n    let log_bytes = get_arr_of_size__log_bytes(lbwop, p);\n    log_bytes\n}\n\n/********************************************************/\n// End of disgusting arithmetic on generics\n/********************************************************/\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<Note, let N: u32>(context: PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\n/// This particular log assembly strategy (AES 128) requires the note (and the\n/// note_id and the storage_slot) to be converted into bytes, because the aes function\n/// operates on bytes; not fields.\n/// NB: The extra `+ 64` bytes is for the note_id and the storage_slot of the note:\nfn compute_note_plaintext_for_this_strategy<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n) -> [u8; N * 32 + 64]\nwhere\n    Note: NoteInterface<N>,\n{\n    let packed_note = note.pack_content();\n\n    let note_header = note.get_header();\n    let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n\n    // TODO(#10952): The following can be reduced to 7 bits\n    let note_type_id_bytes: [u8; 32] = Note::get_note_type_id().to_be_bytes();\n\n    // We combine all the bytes into plaintext_bytes:\n    let mut plaintext_bytes: [u8; N * 32 + 64] = [0; N * 32 + 64];\n    for i in 0..32 {\n        plaintext_bytes[i] = storage_slot_bytes[i];\n        plaintext_bytes[32 + i] = note_type_id_bytes[i];\n    }\n\n    for i in 0..packed_note.len() {\n        let bytes: [u8; 32] = packed_note[i].to_be_bytes();\n        for j in 0..32 {\n            plaintext_bytes[64 + i * 32 + j] = bytes[j];\n        }\n    }\n\n    plaintext_bytes\n}\n\nfn compute_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteInterface<N>,\n{\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient); // not to be confused with the tagging shared secret\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Compute the plaintext\n    // *****************************************************************************\n\n    let final_plaintext_bytes = compute_note_plaintext_for_this_strategy(note, storage_slot);\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt the plaintext\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(final_plaintext_bytes, iv, sym_key);\n\n    // |full_pt| = |pt_length| + |pt|\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    // |ct| = |full_pt| + |pt_aes_padding|\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    //      = 16 + 16 * (|full_pt| // 16)\n    //      = 16 * (1 + |full_pt| // 16)\n    assert(ciphertext_bytes.len() == 16 * (1 + ((N * 32) + 64) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address = context.this_address();\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = 32;\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 =\n        get_arr_of_size__log_bytes_padding__from_PT::<(N * 32) + 64>();\n    /// Safety: this randomness won't be constrained to be random. It's in the\n    /// interest of the executor of this fn to encrypt with random bytes.\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<(N * 32) + 64>();\n\n    assert(\n        log_bytes.len() % 31 == 0,\n        \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n    );\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    assert(\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n        \"Something has gone wrong\",\n    );\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    let log_bytes_as_fields = be_bytes_31_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // In this strategy, we prepend [tag, eph_pk.x]\n\n    // We assume that the sender wants for the recipient to find the tagged note,\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\n    // tag will result in the recipient not being able to find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\n\n    final_log[0] = tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n    offset += log_bytes_as_fields.len();\n\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\n        /// Safety: randomness cannot be constrained.\n        final_log[i] = unsafe { random() };\n    }\n\n    final_log\n}\n\nunconstrained fn compute_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_log(context, note, storage_slot, recipient, sender)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        assert_note_exists(*context, note);\n\n        let note_hash_counter = note.get_header().note_hash_counter;\n\n        let encrypted_log = compute_log(*context, note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n// Important note: this function -- although called \"unconstrained\" -- the\n// function is not labelled as `unconstrained`, because we pass a reference to the\n// context.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        assert_note_exists(*context, note);\n\n        let note_hash_counter = note.get_header().note_hash_counter;\n\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\n        // recipient is unable to decrypt the payload.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        //   It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        let encrypted_log =\n            unsafe { compute_log_unconstrained(*context, note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\nmod test {\n    use crate::test::{helpers::test_environment::TestEnvironment, mocks::mock_note::MockNote};\n    use dep::protocol_types::address::AztecAddress;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n        let mut context = env.private();\n\n        // I'm not sure how to initialise an `env` or `context` with a consistent contract address for every run of this test; the value kept changing each time. So I'm going to overwrite it now:\n        context.inputs.call_context.contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        ); // This is an address copied to match the typescript one.\n\n        let storage_slot = 42;\n        let note = MockNote::new(1234).contract_address(context.this_address()).build();\n        let contract_address = context.this_address();\n\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = super::compute_note_plaintext_for_this_strategy(note, storage_slot);\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = super::compute_log(context, note, storage_slot, recipient, sender);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x0d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701fa7,\n            0x000194e6d7872db8f61e8e59f23580f4db45d13677f873ec473a409cf61fd04d,\n            0x00334e5fb6083721f3eb4eef500876af3c9acfab0a1cb1804b930606fdb0b283,\n            0x00af91db798fa320746831a59b74362dfd0cf9e7c239f6aad11a4b47d0d870ee,\n            0x00d25a054613a83be7be8512f2c09664bc4f7ab60a127b06584f476918581b8a,\n            0x003840d100d8c1d78d4b68b787ed353ebfb8cd2987503d3b472f614f25799a18,\n            0x003f38322629d401010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n            0x0101010101010101010101010101010101010101010101010101010101010101,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n}\n"
    }
  }
}
